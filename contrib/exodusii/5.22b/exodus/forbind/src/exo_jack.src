/*
 * Copyright (c) 2005 Sandia Corporation. Under the terms of Contract
 * DE-AC04-94AL85000 with Sandia Corporation, the U.S. Governement
 * retains certain rights in this software.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 * 
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.  
 * 
 *     * Neither the name of Sandia Corporation nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
/****************************************************************************
*
* exo_jack - exodusII fortran jacket
*
* author - Victor R. Yarberry, Sandia National Laboratories
*
* environment - UNIX
*
* entry conditions - 
*   input parameters:
*
* exit conditions - 
*
* revision history - 
*
*
*****************************************************************************/
%*
%*  Meta-source for various versions of ExodusII FORTRAN jacket library.
%*
%*  Patterned after the jackets.src netCDF library.
%*
%*  02/12/93 V.R. Yarberry
%*  08/31/93 V.R. Yarberry - Modified for cbind Version 2.00
%*
%*  After minor preprocessing via a sed script, this file becomes source
%*  to the m4 macro processor for a C library to be called from FORTRAN.
%*  The main differences between this source and C are the way function
%*  prototypes are declared.  All such declarations occur in lines beginning
%*  with the "%" character.  A sed script converts these into calls to m4
%*  macros for handling the various conventions for calling C functions from
%*  FORTRAN.  Formal parameters corresponding to FORTRAN character strings
%*  must be declared using the pseudo type "string".  Appending "len" to the
%*  name of such variables is the convention used for variables representing
%*  the FORTRAN length of string parameters.
%*
%*  For example, the following input
%*  
%*  % void
%*  % ncadel (
%*  %    int *cdfid,                    /* netCDF ID */
%*  %    int *varid,                    /* variable ID */
%*  %    string attname,                /* attribute name */
%*  %    int *rcode                     /* returned error code */
%*  %    )
%*  % {
%*  
%*  will be converted to the following m4 macro calls:
%*  
%*  void`'M4__dnl
%*  M4__PROTO(`ncadel',
%*      `INTSTAR(cdfid)',
%*      `INTSTAR(varid)',
%*      `STRING(attname)',
%*      `INTSTAR(rcode)'
%*  )
%*  {M4__LOCALS
%*  
%*  which may be converted to the following C, using sun.m4 and common.m4
%*
%*  void
%*  ncadel_ (cdfid, varid, attname, rcode, attnamelen)
%*      int *cdfid;
%*      int *varid;
%*      char *attname;
%*      int attnamelen;
%*      int *rcode;
%*  {
%*
/*
 * OVERVIEW
 *
 * This file contains jacket routines written in C for interfacing Fortran
 * ExodusII function calls to the actual C binding for ExodusII.  This code
 * is written explicitly for M4__SYSTEM.  In general, these functions handle
 * character-string parameter conventions, convert between
 * column-major-order arrays and row-major-order arrays, and map between
 * array indices beginning at one and array indices beginning at zero.
 *
 */

/* LINTLIBRARY */
#include        <ctype.h>
#include        <string.h>
#include        <stdio.h>
#include        <stdlib.h>
#include        "netcdf.h"
#include        "exodusII.h"
#include        "exodusII_int.h"

M4__STRING_DESCRIPTOR_INCLUDES

M4__FORTRAN_DEFINES

extern int ncopts;/* default is (NC_FATAL | NC_VERBOSE) */
extern int exerrval; /* global integer that contains a Exodus-specific error code */

/* blank fill C string to make FORTRAN string */
void
ex_fcdcpy (fstring, fslen, sstring)
    char *fstring;              /* output string to be blank-filled */
    int fslen;                  /* length of output string */
    char *sstring;              /* input string, null-terminated */
{
    int i, len;

    if (sstring != NULL) {
       len = strlen(sstring);
       if (len > fslen) len = fslen;

       for (i = 0; i < len; i++)
           *(fstring + i) = *(sstring + i);
       for (i = len; i < fslen; i++)
           *(fstring + i) = ' ';
   } else {
	for (i = 0; i < fslen; i++)
           *(fstring + i) = ' ';
   }
}

/* ex_lenstr - string length (w/o trailing blanks) */
#ifdef __STDC__
int ex_lenstr (char *string)
#else
int ex_lenstr (string)
     char *string;
#endif
{
  char *ptr;

  ptr=string+strlen(string);    /* start at end of string including blanks */
  while (*(--ptr) == ' ');      /* skip blanks */
  return(ptr-string+1);         /* return trimmed length of string */
}

/* copy function used to copy strings and strip trailing blanks */
void
ex_fstrncpy (target, source, maxlen)
    char *target;               /* space to be copied into */
    char *source;               /* string to be copied */
    int maxlen;                 /* maximum length of *source */
{
    int len=maxlen;

    while (len-- && *source != '\0')
        *target++ = *source++;

    len=maxlen;
    while (len-- && *(--target) == ' ');	/* strip blanks */
    *(++target) = '\0';		/* insert new EOS marker */
}

/* copy function used to copy strings terminated with blanks */
static void
nstrncpy (target, source, maxlen)
    char *target;               /* space to be copied into */
    char *source;               /* string to be copied */
    int maxlen;                 /* maximum length of *source */
{
    while (maxlen-- && *source != ' ')
        *target++ = *source++;
    *target = '\0';
}


/* copy 1D Fortran string arrays into C string arrays */
void fstra2cstra(out_array,in_array,slen,arraylen)
  char *out_array;      /* output character array */
  char *in_array;       /* input character array */
  int slen;             /* length of an individual string */
  int arraylen;         /* array length (Fortran dimension) */
{
  int i;

  while (arraylen--)
  {
    /** if (exoptval & EX_DEBUG) printf("[fstr2cstra] [%d]: ",arraylen); **/
    for (i=0;i<slen;i++)
    {
      /** if (exoptval & EX_DEBUG) printf("%c",*in_array); **/
      *out_array++=*in_array++;
    }
    *out_array++='\0'; /* add string terminator */
    /** if (exoptval & EX_DEBUG) printf("\n"); **/
  }
}
/* copy 1D C string arrays into Fortran string arrays */
void cstra2fstra(out_array,in_array,slen,arraylen)
  char *out_array;      /* output character array */
  char *in_array;       /* input character array */
  int slen;             /* length of an individual string */
  int arraylen;         /* array length (Fortran dimension) */
{
  int i;

  while (arraylen--)
  {
    for (i=0;i<slen;i++)
      *out_array++=*in_array++;
    in_array++; /* skip string terminator */
  }
}

/* copy 2D Fortran string arrays into C string arrays */
void fstra2cstra2d(out_array,in_array,slen,xarraylen,yarraylen)
  char *out_array;      /* output character array */
  char *in_array;       /* input character array */
  int slen;             /* length of an individual string */
  int xarraylen;        /* array length (Fortran 1st dimension) */
  int yarraylen;        /* array length (Fortran 2nd dimension) */
{
  int i,j,k;

/*  char *s;
  s=out_array; */

  for (k=0;k<yarraylen;k++)
  {
    for(j=0;j<xarraylen;j++)
    {
      for (i=0;i<slen;i++)
        *out_array++=*in_array++;
      *out_array++='\0'; /* insert C string terminator */
    /* printf("(%d,%d): %s\n",k,j,s);
      s=out_array; */
    }
  }
}

/* copy 2D C string arrays into Fortran string arrays */
void cstra2fstra2d(out_array,in_array,slen,xarraylen,yarraylen)
  char *out_array;      /* output character array */
  char *in_array;       /* input character array */
  int slen;             /* length of an individual string */
  int xarraylen;        /* array length (Fortran 1st dimension) */
  int yarraylen;        /* array length (Fortran 2nd dimension) */
{
  int i,j,k;

/*  char *s;
  s=out_array; */

  for (k=0;k<xarraylen;k++)
  {
    for(j=0;j<yarraylen;j++)
    {
      for (i=0;i<slen;i++)
        *out_array++=*in_array++;
      in_array++; /* skip string terminator */
    /* printf("(%d,%d): %s\n",k,j,s);
      s=out_array; */
    }
  }
}

#ifdef FORTRAN_HAS_NO_SHORT
/*
 * Convert multi-dimensional array of shorts stored in ints to packed array of
 * shorts, in malloc'ed space.  Returns pointer to shorts or NULL if malloc
 * failed.
 */
static short *
itos(ints, dims, ndims)
     int *ints;         /* multi-dimensional array of ints */
     int *dims;                 /* list of dimensions */
     int ndims;                 /* number of dimensions in list */
{
    long iocount = dimprod (dims, ndims);       /* product of dimensions */
    short *shorts = malloc (iocount * sizeof (short));
    int *ip;
    short *sp = shorts;

    if (shorts != NULL)
      for (ip = ints; iocount > 0; iocount--)
        *sp++ = (short) *ip++;
    return shorts;
}
#endif /* FORTRAN_HAS_NO_SHORT */

/* ------------ M4__SYSTEM FORTRAN jackets for EXODUS II Functions ---------- */

/*
 * create an EXODUS II file
 */
% int
% excre (
%     string path,           /* file name for the new EXODUS II file */
%     int *clobmode,         /* either EXNOCL or EXCLOB */
%     int *cpu_word_size     /* CPU word size */
%     int *io_word_size      /* IO word size */
%     int *ierr              /* returned error code */
%     )
% {

  char errmsg[MAX_ERR_LENGTH];


    char *name;
    int idexo;

    if (!(name = malloc((pathlen+1)*sizeof(char))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to allocate space for file name buffer");
        ex_err("excre",errmsg,EX_MSG);
      }
      return(EX_FATAL);
    }

    (void) nstrncpy (name, path, pathlen);

    if (exoptval & EX_DEBUG) 
      printf("[excre] name: %s, mode: %d\n",name,*clobmode);
    if ((idexo = 
         ex_create (name, *clobmode, cpu_word_size, io_word_size)) != EX_FATAL)
    {
        free(name);
        *ierr = 0;
        return (idexo);
    }
    free(name);
    *ierr = exerrval;
    return (EX_FATAL);
}

/*
 * open an EXODUS II file
 */
% int
% exopen (
%      string path,          /* file name of the EXODUS II file to be opened */
%      int *mode,            /* either EXREAD or EXWRIT */
%      int *cpu_word_size    /* CPU word size */
%      int *io_word_size     /* returned IO word size */
%      float *version,       /* returned EXODUS II version number */
%      int *ierr             /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    char *name;
    int idexo;

    if (!(name = malloc((pathlen+1)*sizeof(char))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to allocate space for file name buffer");
        ex_err("exopen",errmsg,EX_MSG);
      }
      return(EX_FATAL);
    }

    (void) nstrncpy (name, path, pathlen);
    if ((idexo = 
       ex_open (name, *mode, cpu_word_size, io_word_size, version)) != EX_FATAL)
    { 
      free(name);
      if (exoptval & EX_DEBUG) 
        printf("[exopen] file: %d, version: %f\n",
               idexo,*version);
      *ierr = 0;
      return (idexo);
    }
    free(name);
    *ierr = EX_FATAL;
    return (EX_FATAL);
}

/*
 * close an EXODUS II file
 */
% void
% exclos (
%      int *idexo,           /* EXODUS file ID */
%      int *ierr             /* returned error code */
%      )
% {

    *ierr = 0;
    if (ex_close(*idexo) == EX_FATAL)
        *ierr = EX_FATAL;
}

/*
 * update an EXODUS II file
 */
% void
% exupda (
%      int *idexo,           /* EXODUS file ID */
%      int *ierr             /* returned error code */
%      )
% {

    *ierr = 0;
    if (ex_update (*idexo) == EX_FATAL)
        *ierr = EX_FATAL;
}

/*
 * write initialization parameters
 */
% void
% expini (
%      int *idexo,           /* EXODUS file ID */
%      string title,         /* database title */
%      int *num_dim,         /* dimensionality of the database */
%      int *num_nodes,       /* number of nodal points */
%      int *num_elem,        /* number of elements */
%      int *num_elem_blk,    /* number of element blocks */
%      int *num_node_sets,   /* number of node sets */
%      int *num_side_sets,   /* number of side sets */
%      int *ierr             /* returned error code */
%      )
% {

    int slen;
    char* name;

    *ierr = 0;
    slen = MAX_LINE_LENGTH;      /* max line size */
    if (titlelen != MAX_LINE_LENGTH)
    {
      slen = titlelen;
    }

    name = malloc((slen + 1)*sizeof(char));

    (void) ex_fstrncpy (name, title, slen);
    if (ex_put_init (*idexo, name, *num_dim, *num_nodes, *num_elem,
                     *num_elem_blk, *num_node_sets, *num_side_sets) == EX_FATAL)
        *ierr = EX_FATAL;
    free(name);
}

/*
 * read initialization parameters
 */
% void
% exgini (
%      int *idexo,           /* EXODUS file ID */
%      string title,         /* returned database title */
%      int *num_dim,         /* returned dimensionality of the database */
%      int *num_nodes,       /* returned number of nodal points */
%      int *num_elem,        /* returned number of elements */
%      int *num_elem_blk,    /* returned number of element blocks */
%      int *num_node_sets,   /* returned number of node sets */
%      int *num_side_sets,   /* returned number of side sets */
%      int *ierr             /* returned error code */
%      )
% {

    int slen;
    char* name;

    *ierr = 0;
    slen = MAX_LINE_LENGTH;      /* max line size */
    if (titlelen != MAX_LINE_LENGTH)
    {
      slen = titlelen;
    }

    name = malloc((slen + 1)*sizeof(char));
    memset(name, 0, slen+1);

    if (ex_get_init (*idexo, name, num_dim, num_nodes, num_elem, num_elem_blk,
                     num_node_sets, num_side_sets) == EX_FATAL)
        *ierr = EX_FATAL;
    /* printf("title: %s\n",name); */
    ex_fcdcpy (title, slen, name);
    free(name);
}

/*
 * write QA records
 */
% void
% expqa (
%     int *idexo,            /* EXODUS file ID */
%     int *num_qa_records,   /* number of QA records */
%     string qa_record,      /* string containing the QA records */
%                            /* qa records are Fortran character*8 (4,*) */
%     int *ierr              /* returned error code */
%     )
% {

  char errmsg[MAX_ERR_LENGTH];


    char **sptr;  /* internal string pointer array for malloc use */
    int i,ii,iii,slen,alen;

    *ierr=0;     /* default no errror */

    slen = MAX_STR_LENGTH;	/* max str size */
    if (qa_recordlen != MAX_STR_LENGTH)
    {
      slen = qa_recordlen;
    }
    alen = 4;	/* qa records are 4 strings deep */

    /* Allocate space for the name ptr array */
    if (!(sptr=malloc(((*num_qa_records)*alen+1)*sizeof(char *))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
      "Error: failed to allocate space for qa_records ptr array for file id %d",
                *idexo);
        ex_err("expqa",errmsg,EX_MSG);
      }
      return;
    }
    /* Allocate space for each of the strings, where size = slen,
       place ptr into str ptr array,  and
       Copy Fortran qa records to staging space */
    iii = 0; /* offset counter */
    for (i=0;i<*num_qa_records;i++)
    {
      for (ii=0;ii<alen;ii++)
      {
        *(sptr+iii)=malloc((slen+1)*sizeof(char));
        if (*(sptr+iii) == 0)
        {
          free(sptr);	/* free up array ptr space */
	  *ierr = EX_MEMFAIL;
	  sprintf(errmsg,
            "Error: failed to allocate space for qa record %d for file id %d",
                  i,*idexo);
          ex_err("expqa",errmsg,EX_MEMFAIL);
          return;
        }
        /* copy fortran string into allocated space */
        ex_fstrncpy(*(sptr+iii),qa_record+iii*qa_recordlen,slen);
        iii++;	/* bump char array pointer */
      }
    }
    /**printf("[expqa] last i: %d of %d\n",i,alen); **/
    *(sptr+iii) = 0; /* set last pointer to null */

    if (ex_put_qa(*idexo,*num_qa_records,(void *)sptr) == EX_FATAL)
      *ierr=EX_FATAL;

    /* Free up the space we used */
    iii=0;
    for (i=0;i<*num_qa_records;i++)
    {
      for (ii=0;ii<alen;ii++)
      {
        free(*(sptr+iii)); /* First free up string space */
        iii++;
      }
    }
    free(sptr);        /* Then free up array ptr space */
}

/*
 * read QA records
 */
% void
% exgqa (
%     int *idexo,            /* EXODUS file ID */
%     string qa_record,      /* returned string containing the QA records */
%     int *ierr              /* returned error code */
%     )
% {

  char errmsg[MAX_ERR_LENGTH];


    int num_qa_records;
    char **sptr;  /* internal string pointer array for malloc use */
    int i,ii,iii,slen,alen;

    *ierr=0;     /* default no errror */

    slen = MAX_STR_LENGTH;      /* max str size */
    if (qa_recordlen != MAX_STR_LENGTH)
    {
      slen = qa_recordlen;
    }
    alen = 4;   /* qa records are 4 strings deep */

    /* do ExodusII C call to find out how many qa records are avail */
    num_qa_records = ex_inquire_int(*idexo,EX_INQ_QA);

    /** if (exoptval & EX_DEBUG)
	   print("[exgqa] # of QA records: %d\n",num_qa_records); **/
    /* Allocate space for the QA string ptr array */
    if (!(sptr=malloc((num_qa_records*alen+1)*sizeof(char *))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
      "Error: failed to allocate space for qa records ptr array for file id %d",
                *idexo);
        ex_err("exgqa",errmsg,EX_MEMFAIL);
      }
      return;
    }

    /* Step 1: Allocate space for each of the strings, where size = slen,
       		place string ptr into str ptr array.
       Step 2: Call routine to get qa records
       Step 3: Copy C qa records to passed Fortran array space */

    iii = 0; /* offset counter */
    for (i=0;i<num_qa_records;i++) /* pointer allocation loop */
    {
      for (ii=0;ii<alen;ii++)
      {
        *(sptr+iii)=malloc((slen+1)*sizeof(char));
        if (*(sptr+iii) == 0)
        {
          *ierr = EX_MEMFAIL;
          if (exoptval & EX_DEBUG)
          {
            sprintf(errmsg,
              "Error: failed to allocate space for qa record %d for file id %d",
                    i,*idexo);
            ex_err("exgqa",errmsg,EX_MEMFAIL);
          }
          return;
        }
        iii++; /* bump char array pointer */
      }
    }
    *(sptr+iii) = 0; /* null out last pointer */

    /* do ExodusII C call to get qa records */
    if (ex_get_qa(*idexo,(void *)sptr) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get qa records from file id %d",
                *idexo);
        ex_err("exgqa",errmsg,EX_MSG);
      }
      return;
    }

    iii = 0; /* offset counter */
    for (i=0;i<num_qa_records;i++) /* string copy loop */
    {
      for (ii=0;ii<alen;ii++)
      {
        /* copy fortran string into allocated space */
        ex_fcdcpy(qa_record+iii*qa_recordlen,slen,*(sptr+iii));
        iii++;  /* bump char array pointer */
      }
    }

    /* Free up the space we used */
    iii=0;
    for (i=0;i<num_qa_records;i++)
    {
      for (ii=0;ii<alen;ii++)
      {
        free(*(sptr+iii)); /* First free up string space */
        iii++;
      }
    }
    free(sptr);        /* Then free up array ptr space */
}

/*
 * write information records
 */
% void
% expinf (
%      int *idexo,            /* EXODUS file ID */
%      int *num_info,         /* number of information records */
%      string info,           /* array containing the information records */
%      int *ierr              /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    char **aptr;  /* internal string array pointer for malloc use */
    char *sptr;   /* internal string pointer for malloc use */
    int i,slen;

    *ierr=0;     /* default no errror */
    slen = MAX_LINE_LENGTH;	/* max str size */
    if (infolen != MAX_LINE_LENGTH)
    {
      slen = infolen;
    }


    /* Allocate space for the string ptr array */
    if (!(aptr=malloc(((*num_info)+1)*sizeof(char *))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
     "Error: failed to allocate space for info record ptr array for file id %d",
                *idexo);
        ex_err("expinf",errmsg,EX_MEMFAIL);
      }
      return;
    }

    /* Allocate staging space for the info records */
    if (!(sptr=malloc(*num_info*(slen+1)*sizeof(char))))
    { 
      free(aptr);        /* Free up string ptr array */	
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
        "Error: failed to allocate space for info record buffer for file id %d",
                *idexo);
        ex_err("expinf",errmsg,EX_MEMFAIL);
      }
      return;
    }
    /* Copy Fortran info records to staging space */
    for (i=0;i<*num_info;i++)
    {
      *(aptr+i) = sptr+i*(slen+1);		/* put address into ptr array */
      ex_fstrncpy(*(aptr+i),info+i*infolen,slen);	/* copy string into buffer */
    }
    *(aptr+i) = 0; /* null out last ptr */
    if (ex_put_info(*idexo,*num_info,aptr) == EX_FATAL)
    {
      *ierr=EX_FATAL;
      free(sptr);	/* Free up string staging area */
      free(aptr);      /* Free up string ptr array */	
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store info record in file id %d",
                *idexo);
        ex_err("expinf",errmsg,EX_MSG);
      }
      return;
    }

    free(sptr);	/* Free up string staging area */
    free(aptr);        /* Free up string ptr array */	
}

/*
 * read information records
 */
% void
% exginf (
%      int *idexo,            /* EXODUS file ID */
%      string info,           /* returned array containing the information */
%                             /* records */
%      int *ierr              /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    char **aptr;  /* internal string array pointer for malloc use */
    char *sptr;   /* internal string pointer for malloc use */
    int i,slen,num_info;

    *ierr=0;     /* default no errror */

    /* do exodusII C call to find out how many info records are avail */
    num_info = ex_inquire_int(*idexo,EX_INQ_INFO);

    slen = MAX_LINE_LENGTH;	/* max str size */
    if (infolen != MAX_LINE_LENGTH)
    {
      slen = infolen;
    }

    /* Step 1: Allocate space for string ptr array
       Step 2: Allocate space for info record strings, and 
               put pointers into str ptr array
       Step 3: Do ExodusII call to get records
       Step 4: Copy strings into passed Fortran buffer space */

    /* Allocate space for the string ptr array */
    if (!(aptr=malloc((num_info+1)*sizeof(char *))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
            "Error: failed to allocate space for info ptr array for file id %d",
                *idexo);
        ex_err("exginf",errmsg,EX_MEMFAIL);
      }
      return;
    }

    /* Allocate block of space for info strings */
    if (!(sptr=malloc(num_info*(slen+1)*sizeof(char))))
    { 
      free(aptr);	/* Free up string ptr array */	
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
              "Error: failed to allocate space for info records for file id %d",
                *idexo);
        ex_err("exginf",errmsg,EX_MEMFAIL);
      }
      return;
    }
    for (i=0;i<num_info;i++) /* Put pointers to the info records in ptr array */
      *(aptr+i) = sptr+i*(slen+1);	/* put ptr in string ptr array */
    *(aptr+i) = 0;	/* null out last pointer */

    /* Do exodusII call to get info records */
    if (ex_get_info(*idexo,aptr) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      free(sptr);
      free(aptr);
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get info records from file id %d",
                *idexo);
        ex_err("exginf",errmsg,EX_MSG);
      }
      return;
    }

    for (i=0;i<num_info;i++) /* Copy Fortran info records to staging space */
    {
      ex_fcdcpy(info+i*infolen,slen,*(aptr+i));	/* copy string into buffer */
      /** printf("[exginf] rec: %d , %s\n",i,*(aptr+i)); **/
    }

    free(sptr);	/* Free up string staging area */
    free(aptr);        /* Free up string ptr array */	

}

/*
 * write nodal coordinates
 */
% void
% expcor (
%      int *idexo,            /* EXODUS file ID */
%      real *x_coor,         /* x coordinates of the nodes */
%      real *y_coor,         /* y coordinates of the nodes */
%      real *z_coor,         /* z coordinates of the nodes */
%      int *ierr              /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_put_coord (*idexo, x_coor, y_coor, z_coor) == EX_FATAL)
    {
        *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store coordinates in file id %d",
                *idexo);
        ex_err("expcor",errmsg,EX_MSG);
      }

    }
}
 
/*
 * read nodal coordinates
 */
% void
% exgcor (
%      int *idexo,            /* EXODUS file ID */
%      real *x_coor,         /* returned x coordinates of the nodes */
%      real *y_coor,         /* returned y coordinates of the nodes */
%      real *z_coor,         /* returned z coordinates of the nodes */
%      int *ierr              /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_get_coord (*idexo, x_coor, y_coor, z_coor) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get coordinates from file id %d",
                *idexo);
        ex_err("exgcor",errmsg,EX_MSG);
      }
    }
}

/*
 * write coordinate names
 */
% void
% expcon (
%      int *idexo,            /* EXODUS file ID */
%      string coord_names,    /* array containing names for the nodal */
%                             /* coordinates */
%      int *ierr              /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];



    char **aptr;  /* internal array of string pointers for malloc use */
    char *sptr;   /* internal string pointer for malloc use */
    int i,ndim,slen;

    *ierr=0;     /* default no errror */

    slen = ex_inquire_int(*idexo, EX_INQ_DB_MAX_ALLOWED_NAME_LENGTH);	/* max str size */
    if (coord_nameslen < slen)
    {
      slen = coord_nameslen;
    }
    /* do ExodusII C call to find out how many dimensions  */
    ndim = ex_inquire_int(*idexo,EX_INQ_DIM);

    /* Allocate space for the name ptr array */
    if (!(aptr=malloc((ndim+1)*sizeof(char *))))
    { 
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
 "Error: failed to allocate space for coordinate name ptr array for file id %d",
                *idexo);
        ex_err("expcon",errmsg,EX_MEMFAIL);
      }
      return;
    }
    /* Allocate a block of space for the strings, where size = slen,
       place ptrs into str ptr array,  and
       Copy Fortran coordinate names to staging space */

    if(!(sptr=malloc(ndim*(slen+1)*sizeof(char))))
    {
      *ierr = EX_MEMFAIL;
      free(aptr);
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
    "Error: failed to allocate space for coordinate name buffer for file id %d",
                *idexo);
        ex_err("expcon",errmsg,EX_MEMFAIL);
      }
      return;
    }

    for (i=0;i<ndim;i++)
    {
      *(aptr+i) = sptr+i*(slen+1);
      /* copy fortran string into allocated space */
      ex_fstrncpy(*(aptr+i),coord_names+i*coord_nameslen,slen);
    }
    *(aptr+i) = 0; /* set last pointer to null */

    if (ex_put_coord_names(*idexo,aptr) == EX_FATAL)
    {
      *ierr=EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store coordinate names in file id %d",
                *idexo);
        ex_err("expcon",errmsg,EX_MSG);
      }
    }
    /* Free up the space we used */
    free(sptr);	/* First free up string space */
    free(aptr);	/* Then free up array ptr space */
}
/*
 * read coordinate names
 */
% void
% exgcon (
%      int *idexo,            /* EXODUS file ID */
%      string coord_names,    /* returned array containing names for the */
%                             /* nodal coordinates */
%      int *ierr              /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    char **aptr;  /* internal string array pointer for malloc use */
    char *sptr;   /* internal string pointer for malloc use */
    int ndim;
    int i,slen;

    *ierr = 0; /* default no error */

    /** if (exoptval & EX_DEBUG)
      printf("[exgcon] Fortran target loc: %ld\n",coord_names); **/
    slen = ex_max_name_length; /* max string size */
    if (coord_nameslen < slen)
    {
      slen = coord_nameslen;
    }

    /* do ExodusII C call to find out how many dimensions */
    ndim = ex_inquire_int(*idexo,EX_INQ_DIM);

    /* allocate memory to stage the coordinate name ptrs into */
    if (!(aptr = malloc((ndim+1)*sizeof(char *))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
 "Error: failed to allocate space for coordinate name ptr array for file id %d",
                *idexo);
        ex_err("exgcon",errmsg,EX_MEMFAIL);
      }
      return;
    }
    /** if (exoptval & EX_DEBUG)
      printf("[exgcon] str ptr array: %ld\n",aptr); **/

    /* allocate a block of memory to stage the coordinate names into */
    if (!(sptr=malloc(ndim*(slen+1)*sizeof(char))))
    {
      *ierr = EX_MEMFAIL;
      free(aptr);		/* free up array ptr space */
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
    "Error: failed to allocate space for coordinate name buffer for file id %d",
                *idexo);
        ex_err("exgcon",errmsg,EX_MEMFAIL);
      }
      return;
    }
    /** if (exoptval & EX_DEBUG)
      printf("[exgcon] str ptr buffer base: %ld\n",sptr); **/

    for (i=0;i<ndim;i++) /* put pointers to staging space into ptr array */
    {
      *(aptr+i)=sptr+i*(slen+1);
      /** if (exoptval & EX_DEBUG) printf("[exgcon] i: %d, ptr: %ld, buf:%ld\n",
					i,aptr+i,*(aptr+i)); **/
    }

    /* do ExodusII C call to get coord name records */
    if (ex_get_coord_names(*idexo,aptr) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      free(sptr);		/* free up string space */
      free(aptr);		/* free up array ptr space */
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get coordinate names from file id %d",
                *idexo);
        ex_err("exgcon",errmsg,EX_MSG);
      }
      return;
    }

    /* copy C strings to Fortran arrays */
    memset(coord_names, 0, ndim*coord_nameslen);
    for (i=0;i<ndim;i++)
    {
      if (exoptval & EX_DEBUG)
        printf("[exgcon] name(%d): %s\n",i,*(aptr+i));
      ex_fcdcpy(coord_names+i*coord_nameslen,slen,*(aptr+i)); /* copy and blank fill */
    }

    free(sptr);        /* Free up string buffer space */
    free(aptr);        /* Finally, free up array ptr space */
    return;
}

/*
 * write element order map
 */
% void
% expmap (
%      int *idexo,            /* EXODUS file ID */
%      int *elem_map,         /* element order map */
%      int *ierr              /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_put_map (*idexo, elem_map) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store element order map in file id %d",
                *idexo);
        ex_err("expmap",errmsg,EX_MSG);
      }
    }
}

/*
 * read element order map
 */
% void
% exgmap (
%      int *idexo,            /* EXODUS file ID */
%      int *elem_map,         /* returned element order map */
%      int *ierr              /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_get_map (*idexo, elem_map) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get element order map from file id %d",
                *idexo);
        ex_err("exgmap",errmsg,EX_MSG);
      }
    }
}

/*
 * write concatenated element block parameters
 */
% void
% expclb (
%      int *idexo,             /* EXODUS file ID */
%      int *elem_blk_id,       /* element block IDs */
%      string elem_type,       /* type of elements in each element block */
%      int *num_elem_this_blk, /* number of elements in each element block */
%      int *num_nodes_per_elem,/* number of nodes per element in each element */
%                              /* block */
%      int *num_attr,          /* number of attributes in each element block */
%      int *create_maps,       /* TRUE/FALSE should library define maps? */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    int num_elem_blk;

    char **aptr;/* ptr to temp staging space for string array ptrs */
    char *sptr; /* ptr to temp staging space for strings */
    int i, slen;

    *ierr = 0; /* default no error */

    num_elem_blk = ex_inquire_int(*idexo,EX_INQ_ELEM_BLK);

    slen = MAX_STR_LENGTH;     /* max str size */
    if (elem_typelen != MAX_STR_LENGTH)
    {
      slen = elem_typelen;
    }


    /* allocate memory for pointer array */
    if (!(aptr=malloc((num_elem_blk+1)*sizeof(char *))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
  "Error: failed to allocate space for element block type names ptr array for file id %d",
                *idexo);
        ex_err("expclb",errmsg,EX_MEMFAIL);
      }
      return;
    }

    /* allocate memory to stage the element type name into */
    if (!(sptr=malloc(num_elem_blk*(slen+1)*sizeof(char))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
  "Error: failed to allocate space for element type name buffer for file id %d",
                *idexo);
        ex_err("expclb",errmsg,EX_MEMFAIL);
      }
      return;
    }

    /* Copy element type names from Fortran array to staging area */
    for (i=0;i<num_elem_blk;i++)
    {
      *(aptr+i) = sptr+i*(slen+1);		/* put address into ptr array */
      ex_fstrncpy(*(aptr+i),elem_type+i*elem_typelen,slen);/* copy string into buffer */
    }
    *(aptr+i) = 0; /* null out last ptr */

    if (ex_put_concat_elem_block (*idexo, elem_blk_id, aptr, num_elem_this_blk,
				  num_nodes_per_elem, num_attr, *create_maps) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store element block parameters in file id %d",
                *idexo);
        ex_err("expclb",errmsg,EX_MSG);
      }
    }
    free(sptr);
    free(aptr);
}

/*
 * write element block parameters
 */
% void
% expelb (
%      int *idexo,             /* EXODUS file ID */
%      int *elem_blk_id,       /* element block ID */
%      string elem_type,       /* type of elements in the element block */
%      int *num_elem_this_blk, /* number of elements in the element block */
%      int *num_nodes_per_elem,/* number of nodes per element in the element */
%                              /* block */
%      int *num_attr,          /* number of attributes in the element block */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    char *sptr;  /* internal string pointer for malloc use */
    int slen;

    *ierr = 0; /* default no error */

    slen = MAX_STR_LENGTH;     /* max str size */
    if (elem_typelen != MAX_STR_LENGTH)
    {
      slen = elem_typelen;
    }


    /** if (exoptval & EX_DEBUG) print(
  "[expelb] file ID: %d, Elem blk ID: %d, #Elem: %d, #Nodes: %d, #Attrib: %d\n",
    *idexo,*elem_blk_id,*num_elem_this_blk,*num_nodes_per_elem,*num_attr); **/

    /* allocate memory to stage the element type name into */
    if (!(sptr=malloc((slen+1)*sizeof(char))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
  "Error: failed to allocate space for element type name buffer for file id %d",
                *idexo);
        ex_err("expelb",errmsg,EX_MEMFAIL);
      }
      return;
    }

    /* Copy element type names from Fortran array to staging area */
    ex_fstrncpy(sptr,elem_type,slen);

    if (ex_put_elem_block (*idexo, *elem_blk_id, sptr, *num_elem_this_blk,
                           *num_nodes_per_elem, *num_attr) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store element block parameters in file id %d",
                *idexo);
        ex_err("expelb",errmsg,EX_MSG);
      }
    }
    free(sptr);
}

/*
 * read element block parameters
 */
% void
% exgelb (
%      int *idexo,             /* EXODUS file ID */
%      int *elem_blk_id,       /* element block ID */
%      string elem_type,       /* type of elements in the element block */
%      int *num_elem_this_blk, /* returned number of elements in the element */
%                              /* block */
%      int *num_nodes_per_elem,/* returned number of nodes per element in the */
%                              /* element block */
%      int *num_attr,          /* returned number of attributes in the */
%                              /* element block */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    char *sptr; /* internal string pointer for malloc use */
    int slen;

    *ierr = 0;

    slen = MAX_STR_LENGTH;     /* max str size */
    if (elem_typelen != MAX_STR_LENGTH)
    {
      slen = elem_typelen;
    }

    /* allocate memory to stage the element type names into */
    if (!(sptr=malloc((slen+1)*sizeof(char))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
  "Error: failed to allocate space for element type name buffer for file id %d",
                *idexo);
        ex_err("exgelc",errmsg,EX_MEMFAIL);
      }
      return;
    }

    if (ex_get_elem_block (*idexo, *elem_blk_id, sptr, num_elem_this_blk,
                            num_nodes_per_elem,num_attr) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to read element block parameters in file id %d",
                *idexo);
        ex_err("exgelb",errmsg,EX_MSG);
      }
      return;
    }
    /* Copy element type name from staging area to Fortran array */
    memset(elem_type, 0, elem_typelen);
    ex_fcdcpy (elem_type, slen, sptr);
/*    cstra2fstra(sptr,elem_type,elem_typelen,num_elem_this_blk); */
    free(sptr);

}

/*
 * read element blocks IDs
 */
% void
% exgebi (
%      int *idexo,             /* EXODUS file ID */
%      int *elem_blk_ids,      /* returned array of element blocks IDs */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_get_elem_blk_ids (*idexo, elem_blk_ids) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get element block ids from file id %d",
                *idexo);
        ex_err("exgebi",errmsg,EX_MSG);
      }
    }
}

/*
 * write element block connectivity
 */
% void
% expelc (
%      int *idexo,             /* EXODUS file ID */
%      int *elem_blk_id,       /* element block ID */
%      int *connect,           /* connectivity array */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];



    *ierr = 0;

    /* do ExodusII C call to write the element block connectivity */
    if (ex_put_elem_conn(*idexo,*elem_blk_id,connect) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store element block connectivitys in file id %d",
                *idexo);
        ex_err("expelc",errmsg,EX_MSG);
      }
    }
}

/*
 * read element block connectivity
 */
% void
% exgelc (
%      int *idexo,             /* EXODUS file ID */
%      int *elem_blk_id,       /* element block ID */
%      int * connect,          /* returned connectivity array */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];



    *ierr = 0;

    /* do ExodusII C call to read the element block connectivity */
    if (ex_get_elem_conn(*idexo,*elem_blk_id,connect) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get element block connectivity from file id %d",
                *idexo);
        ex_err("exgelc",errmsg,EX_MSG);
      }
      return;
    }
}

/*
 * write entity count-per-polyhedra information for nsided block
 */
% void
% expecpp (
%      int *idexo,             /* EXODUS file ID */
%      int *obj_type,          /* object type code */
%      int *elem_blk_id,       /* element block ID */
%      int *counts,            /* entity count-per-polyhedra array */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];

    *ierr = 0;

    if (ex_put_entity_count_per_polyhedra(*idexo,(ex_entity_type)*obj_type,*elem_blk_id, counts) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store entity_count-per-polyhedra information in file id %d",
                *idexo);
        ex_err("expecpp",errmsg,EX_MSG);
      }
    }
}

/*
 * read entity count-per-polyhedra information for nsided block
 */
% void
% exgecpp (
%      int *idexo,             /* EXODUS file ID */
%      int *obj_type,          /* object type code */
%      int *elem_blk_id,       /* element block ID */
%      int *counts,            /* entity count-per-polyhedra array */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];

    *ierr = 0;

    if (ex_get_entity_count_per_polyhedra(*idexo,(ex_entity_type)*obj_type,*elem_blk_id,counts) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get entity_count-per-polyhedra information from file id %d",
                *idexo);
        ex_err("exgecpp",errmsg,EX_MSG);
      }
      return;
    }
}

/*
 * write element block attributes
 */
% void
% expeat (
%      int *idexo,             /* EXODUS file ID */
%      int *elem_blk_id,       /* element block ID */
%      real *attrib,           /* list of attributes for the element block */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];

/* WARNING - this routine must be fixed for multiple attributed blocks !!! */
    *ierr = 0;
    /** if (exoptval & EX_DEBUG) 
	printf("[expeat] file ID: %d, elem_blk_id: %d, attrib: %f\n",
          	*idexo,*elem_blk_id,*attrib); **/
    if (ex_put_elem_attr(*idexo,*elem_blk_id,attrib) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store element block attributes in file id %d",
                *idexo);
        ex_err("expeat",errmsg,EX_MSG);
      }
    }
}


/*
 * read element block attributes
 */
% void
% exgeat (
%      int *idexo,             /* EXODUS file ID */
%      int *elem_blk_id,       /* element block ID */
%      real *attrib,          /* returned list of attributes for the element */
%                              /* block */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];

/* WARNING - this routine must be fixed for multiple attributed blocks !!! */

    *ierr = 0;
    if (ex_get_elem_attr(*idexo,*elem_blk_id,attrib) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get element block attributes from file id %d",
                *idexo);
        ex_err("exgeat",errmsg,EX_MSG);
      }
    }
}

/*
 * read element block attribute names
 */
% void
% exgean (
%      int *idexo,             /* EXODUS file ID */
%      int *elem_blk_id,       /* element block ID */
%      int *num_attr,          /* number of attributes */
%      string names,           /* string containing attribute names */
%                              /* block */
%      int *ierr               /* returned error code */
%      )
% {

    char errmsg[MAX_ERR_LENGTH];

    char **aptr;/* ptr to temp staging space for string array ptrs */
    char *sptr; /* ptr to temp staging space for strings */
    int i,slen;

    *ierr=0;     /* default no errror */

    slen = ex_max_name_length;	/* max str size */
    if (nameslen < slen)
    {
      slen = nameslen;
    }

    /* allocate memory to for pointer array */
    if (!(aptr=malloc((*num_attr+1)*sizeof(char *))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
                "Error: failed to allocate space for element attribute names ptr array for file id %d",
                *idexo);
        ex_err("exgean",errmsg,EX_MEMFAIL);
      }
      return;
    }

    /* Allocate staging space for the variable names */
    if (!(sptr=malloc(*num_attr*(slen+1)*sizeof(char))))
    { 
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
    "Error: failed to allocate space for object names for file id %d",
                *idexo);
        ex_err("exgean",errmsg,EX_MEMFAIL);
      }
      free(aptr);        /* Free up string ptr array */	
      return;
    }
    for (i=0;i<*num_attr;i++)
      *(aptr+i) = sptr+i*(slen+1);              /* put address into ptr array */
    *(aptr+i) = 0; /* null out last ptr */

    *ierr = 0;
    if (ex_get_elem_attr_names(*idexo,*elem_blk_id, aptr) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      free(sptr);	/* free up allocated space */  
      free(aptr);
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get element block attribute names from file id %d",
                *idexo);
        ex_err("exgean",errmsg,EX_MSG);
      }
    }
    /* Copy Fortran names from staging space */
    memset(names, 0, *num_attr*nameslen);
    for (i=0;i<*num_attr;i++)
    {
	ex_fcdcpy(names+i*nameslen,slen,*(aptr+i));/* copy str into Fortran buffer */
    }

    free(sptr);	/* Free up string staging area */
    free(aptr);        /* Free up string ptr array */	
}

/*
 * write element block attribute names
 */
% void
% expean (
%      int *idexo,             /* EXODUS file ID */
%      int *elem_blk_id,       /* element block ID */
%      int *num_attr,          /* number of attributes */
%      string names,           /* string containing attribute names */
%                              /* block */
%      int *ierr               /* returned error code */
%      )
% {

    char errmsg[MAX_ERR_LENGTH];

    char **aptr;/* ptr to temp staging space for string array ptrs */
    char *sptr; /* ptr to temp staging space for strings */
    int i,slen;

    *ierr=0;     /* default no errror */

    slen = ex_inquire_int(*idexo, EX_INQ_DB_MAX_ALLOWED_NAME_LENGTH);	/* max str size */
    if (nameslen < slen)
    {
      slen = nameslen;
    }

    /* allocate memory to for pointer array */
    if (!(aptr=malloc((*num_attr+1)*sizeof(char *))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
                "Error: failed to allocate space for element attribute names ptr array for file id %d",
                *idexo);
        ex_err("expean",errmsg,EX_MEMFAIL);
      }
      return;
    }

    /* Allocate staging space for the variable names */
    if (!(sptr=malloc(*num_attr*(slen+1)*sizeof(char))))
    { 
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
    "Error: failed to allocate space for object names for file id %d",
                *idexo);
        ex_err("expean",errmsg,EX_MEMFAIL);
      }
      free(aptr);        /* Free up string ptr array */	
      return;
    }

    /* Copy Fortran names to staging space */
    for (i=0;i<*num_attr;i++)
    {
      *(aptr+i) = sptr+i*(slen+1);		/* put address into ptr array */
      ex_fstrncpy(*(aptr+i),names+i*nameslen,slen);/* copy string into buffer */
    }
    *(aptr+i) = 0; /* null out last ptr */

    *ierr = 0;
    if (ex_put_elem_attr_names(*idexo,*elem_blk_id, aptr) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store element block attribute names from file id %d",
                *idexo);
        ex_err("expean",errmsg,EX_MSG);
      }
    }
    free(sptr);	/* Free up string staging area */
    free(aptr); /* Free up string ptr array */	
}

/*
 * write object names
 */
% void
% expnams (
%      int *idexo,             /* EXODUS file ID */
%      int *type,             /* type of objects which are described */
%      int *num_obj,           /* number of objects of specified type */
%      string names,           /* string containing object names */
%      int *ierr               /* returned error code */
%      )
% {
  
  char errmsg[MAX_ERR_LENGTH];


    char **aptr;/* ptr to temp staging space for string array ptrs */
    char *sptr; /* ptr to temp staging space for strings */
    int i,slen;

    *ierr=0;     /* default no errror */

    slen = ex_inquire_int(*idexo, EX_INQ_DB_MAX_ALLOWED_NAME_LENGTH);	/* max str size */
    if (nameslen < slen)
    {
      slen = nameslen;
    }

    /* allocate memory for pointer array */
    if (!(aptr=malloc((*num_obj+1)*sizeof(char *))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
  "Error: failed to allocate space for variable names ptr array for file id %d",
                *idexo);
        ex_err("expnams",errmsg,EX_MEMFAIL);
      }
      return;
    }

    /* Allocate staging space for the variable names */
    if (!(sptr=malloc(*num_obj*(slen+1)*sizeof(char))))
    { 
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
     "Error: failed to allocate space for variable names buffer for file id %d",
                *idexo);
        ex_err("expnams",errmsg,EX_MEMFAIL);
      }
      free(aptr);        /* Free up string ptr array */	
      *ierr = EX_MEMFAIL;
      return;
    }
    /* Copy Fortran names to staging space */
    for (i=0;i<*num_obj;i++)
    {
      *(aptr+i) = sptr+i*(slen+1);		/* put address into ptr array */
      ex_fstrncpy(*(aptr+i),names+i*nameslen,slen);/* copy string into buffer */
    }
    *(aptr+i) = 0; /* null out last ptr */
    /* do ExodusII C call to write results variables names */
    if (ex_put_names(*idexo,(ex_entity_type)*type,aptr) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store object names in file id %d",
                *idexo);
        ex_err("expnams",errmsg,EX_MSG);
      }
    }

    free(sptr);	/* Free up string staging area */
    free(aptr);        /* Free up string ptr array */	
}
/*
 * read object names
 */
% void
% exgnams (
%      int *idexo,         /* EXODUS file ID */
%      int *type,          /* type of object which is described */
%      int *num_obj,       /* number of 'type' names to be read */
%      string names,       /* returned string containing num_obj names */
%      int *ierr           /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];

    char **aptr;/* ptr to temp staging space for string array ptrs */
    char *sptr; /* ptr to temp staging space for strings */
    int i,slen;

    *ierr=0;     /* default no errror */

    slen = ex_max_name_length;	/* max str size */
    if (nameslen < slen)
    {
      slen = nameslen;
    }

    /* allocate memory to for pointer array */
    if (!(aptr=malloc((*num_obj+1)*sizeof(char *))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
                "Error: failed to allocate space for results variable names ptr array for file id %d",
                *idexo);
        ex_err("exgvan",errmsg,EX_MEMFAIL);
      }
      return;
    }

    /* Allocate staging space for the variable names */
    if (!(sptr=malloc(*num_obj*(slen+1)*sizeof(char))))
    { 
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
    "Error: failed to allocate space for object names for file id %d",
                *idexo);
        ex_err("exgnams",errmsg,EX_MEMFAIL);
      }
      free(aptr);        /* Free up string ptr array */	
      return;
    }
    for (i=0;i<*num_obj;i++)
      *(aptr+i) = sptr+i*(slen+1);              /* put address into ptr array */
    *(aptr+i) = 0; /* null out last ptr */

    /* do ExodusII C call to read results variables names */
    if (ex_get_names(*idexo,(ex_entity_type)*type,aptr) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      free(sptr);	/* free up allocated space */  
      free(aptr);
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get results variable names from file id %d",
                *idexo);
        ex_err("exgnams",errmsg,EX_MSG);
      }
      return;
    }

    /* Copy Fortran names from staging space */
    memset(names, 0, *num_obj*nameslen);
    for (i=0;i<*num_obj;i++)
    {
	ex_fcdcpy(names+i*nameslen,slen,*(aptr+i));/* copy str into Fortran buffer */
    }

    free(sptr);	/* Free up string staging area */
    free(aptr);        /* Free up string ptr array */	
}

/*
 * write property array names
 */
% void
% exppn (
%      int *idexo,             /* EXODUS file ID */
%      int *obj_type,          /* object type code */
%      int *num_props,         /* number of properties */
%      string prop_names       /* character array of property names */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];

    char **aptr;  /* internal string array pointer for malloc use */
    char *sptr;  /* internal string pointer for malloc use */
    int i, slen;

    *ierr = 0;

    slen = ex_inquire_int(*idexo, EX_INQ_DB_MAX_ALLOWED_NAME_LENGTH);	/* max str size */
    if (prop_nameslen < slen)
    {
      slen = prop_nameslen;
    }

    /* Allocate space for the name ptr array */
    if (!(aptr=malloc((*num_props+1)*sizeof(char *))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
 "Error: failed to allocate space for property name ptr array for file id %d",
                *idexo);
        ex_err("exppn",errmsg,EX_MEMFAIL);
      }
      return;
    }

    /* Allocate a block of space for the strings, where size = slen,
       place ptrs into str ptr array,  and
       Copy Fortran coordinate names to staging space */

    if(!(sptr=malloc((*num_props)*(slen+1)*sizeof(char))))
    {
      *ierr = EX_MEMFAIL;
      free(aptr);
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
      "Error: failed to allocate space for property name buffer for file id %d",
                *idexo);
        ex_err("exppn",errmsg,EX_MEMFAIL);
      }
      return;
    }

    for (i=0;i<*num_props;i++)
    {
      *(aptr+i) = sptr+i*(slen+1);
    /* copy fortran string into allocated space */
      ex_fstrncpy(*(aptr+i),prop_names+i*prop_nameslen,slen);
    }
    *(aptr+i) = 0; /* set last pointer to null */


    if (ex_put_prop_names(*idexo,(ex_entity_type)*obj_type, *num_props, aptr) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store property names in file id %d",
                *idexo);
        ex_err("exppn",errmsg,EX_MSG);
      }
    }
    /* Free up the space we used */
    free(sptr);        /* First free up string space */
    free(aptr);        /* Then free up array ptr space */
}


/*
 * read property array names
 */
% void
% exgpn (
%      int *idexo,             /* EXODUS file ID */
%      int *obj_type,          /* object type code */
%      string prop_names       /* character array of property names */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];

    char **aptr;  /* internal string array pointer for malloc use */
    char *sptr;  /* internal string pointer for malloc use */
    int i, slen;
    ex_inquiry inq_code;
    int num_props;

    *ierr = 0;

    slen = ex_max_name_length;     /* max str size */
    if (prop_nameslen < slen)
    {
      slen = prop_nameslen;
    }

    switch ((ex_entity_type)*obj_type)
    {
      case EX_ELEM_BLOCK:
        inq_code = EX_INQ_EB_PROP;
        break;
      case EX_NODE_SET:
        inq_code = EX_INQ_NS_PROP;
        break;
      case EX_SIDE_SET:
        inq_code = EX_INQ_SS_PROP;
        break;
      case EX_ELEM_MAP:
        inq_code = EX_INQ_EM_PROP;
        break;
      case EX_NODE_MAP:
        inq_code = EX_INQ_NM_PROP;
        break;
      default:
        exerrval = EX_BADPARAM;
        *ierr = EX_BADPARAM;
        sprintf(errmsg, "Error: object type %d not supported; file id %d",
                *obj_type, *idexo);
        ex_err("exgpn",errmsg,exerrval);
        return;
     }

    
    /* do ExodusII C call to find out how many properties */
    num_props = ex_inquire_int(*idexo,inq_code);

    /* Allocate space for the name ptr array */
    if (!(aptr=malloc((num_props+1)*sizeof(char *))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
 "Error: failed to allocate space for property name ptr array for file id %d",
                *idexo);
        ex_err("exgpn",errmsg,EX_MEMFAIL);
      }
      return;
    }

    /* Allocate a block of space for the strings, where size = slen,
       place ptrs into str ptr array,  and
       Copy Fortran coordinate names to staging space */

    if(!(sptr=malloc(num_props*(slen+1)*sizeof(char))))
    {
      *ierr = EX_MEMFAIL;
      free(aptr);
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
      "Error: failed to allocate space for property name buffer for file id %d",
                *idexo);
        ex_err("exgpn",errmsg,EX_MEMFAIL);
      }
      return;
    }
    memset(sptr, 0, num_props*(slen+1));

    for (i=0;i<num_props;i++)
      *(aptr+i) = sptr+i*(slen+1);/* put ptrs to staging space into ptr array */
    *(aptr+i) = 0; /* set last pointer to null */

    /* do ExodusII C call to get property name records */
    if (ex_get_prop_names(*idexo,(ex_entity_type)*obj_type, aptr) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      free(sptr);              /* free up string space */
      free(aptr);              /* free up array ptr space */
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get property names in file id %d",
                *idexo);
        ex_err("exgpn",errmsg,EX_MSG);
      }
      return;
    }
    /* copy C strings to Fortran arrays */
    memset(prop_names, 0, num_props*prop_nameslen);
    for (i=0;i<num_props;i++)
    {
      if (exoptval & EX_DEBUG)
        printf("[exgpn] name(%d): %s\n",i,*(aptr+i));
      ex_fcdcpy(prop_names+i*prop_nameslen,slen,*(aptr+i)); /* copy and blank fill */
    }

    /* Free up the space we used */
    free(sptr);        /* First free up string space */
    free(aptr);        /* Then free up array ptr space */
}

/*
 * write object property
 */
% void
% expp (
%      int *idexo,             /* EXODUS file ID */
%      int *obj_type,          /* object type code */
%      int *obj_id,            /* object id code */
%      string prop_name,       /* property name */
%      int *value,             /* property value */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];

    char *sptr;  /* internal string pointer for malloc use */
    int slen;

    *ierr = 0;

    slen = ex_inquire_int(*idexo, EX_INQ_DB_MAX_ALLOWED_NAME_LENGTH);	/* max str size */
    if (prop_namelen < slen)
    {
      slen = prop_namelen;
    }

    /* allocate memory to stage the property name into */
    if (!(sptr=malloc((slen+1)*sizeof(char))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
  "Error: failed to allocate space for property name buffer for file id %d",
                *idexo);
        ex_err("expp",errmsg,EX_MEMFAIL);
      }
      return;
    }
    /* Copy property name from Fortran string to staging area */
    /* nstrncpy(sptr,prop_name,slen); */
    ex_fstrncpy(sptr,prop_name,slen);

    if (ex_put_prop (*idexo, (ex_entity_type)*obj_type, *obj_id, sptr, *value) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store property names in file id %d",
                *idexo);
        ex_err("expp",errmsg,EX_MSG);
      }
    }
    free(sptr);
}

/*
 * read object property
 */
% void
% exgp (
%      int *idexo,             /* EXODUS file ID */
%      int *obj_type,          /* object type code */
%      int *obj_id,            /* object id code */
%      string prop_name,       /* property name */
%      int *value,             /* returned property value */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    char *sptr;  /* internal string pointer for malloc use */
    int slen;

    *ierr = 0;

    slen = ex_max_name_length;     /* max str size */
    if (prop_namelen < slen)
    {
      slen = prop_namelen;
    }

    /* allocate memory to stage the property name into */
    if (!(sptr=malloc((slen+1)*sizeof(char))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
  "Error: failed to allocate space for property name buffer for file id %d",
                *idexo);
        ex_err("exgp",errmsg,EX_MEMFAIL);
      }
    }

    /* Copy property name from Fortran string to staging area */
    ex_fstrncpy(sptr,prop_name,slen);

    /* use exodusII C routine to get the property value */
    if (ex_get_prop (*idexo, (ex_entity_type)*obj_type, *obj_id, sptr, value) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get %s property value in file id %d",
                sptr, *idexo);
        ex_err("exgp",errmsg,EX_MSG);
      }
    }
    free(sptr);
}

/*
 * read object property array
 */
% void
% exgpa (
%      int *idexo,             /* EXODUS file ID */
%      int *obj_type,          /* object type code */
%      string prop_name,       /* property name */
%      int *values,            /* returned property values array */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    char *sptr;  /* internal string pointer for malloc use */
    int slen;

    *ierr = 0;

    slen = ex_max_name_length;     /* max str size */
    if (prop_namelen < slen)
    {
      slen = prop_namelen;
    }

    /* allocate memory to stage the property name into */
    if (!(sptr=malloc((slen+1)*sizeof(char))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
  "Error: failed to allocate space for property name buffer for file id %d",
                *idexo);
        ex_err("exgpa",errmsg,EX_MEMFAIL);
      }
    }
    memset(sptr, 0, slen+1);

    /* Copy property name from Fortran string to staging area */
    ex_fstrncpy(sptr,prop_name,slen);


    /* use exodusII C routine to get the values array */
    if (ex_get_prop_array (*idexo, (ex_entity_type)*obj_type, sptr, values) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get %s property values in file id %d",
                sptr, *idexo);
        ex_err("exgpa",errmsg,EX_MSG);
      }
    }
    free(sptr);
}

/*
 * write object property array
 */
% void
% exppa (
%      int *idexo,             /* EXODUS file ID */
%      int *obj_type,          /* object type code */
%      string prop_name,       /* property name */
%      int *values,            /* property values array */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    char *sptr;  /* internal string pointer for malloc use */
    int slen;

    *ierr = 0;

    slen = ex_inquire_int(*idexo, EX_INQ_DB_MAX_ALLOWED_NAME_LENGTH);	/* max str size */
    if (prop_namelen < slen)
    {
      slen = prop_namelen;
    }

    /* allocate memory to stage the property name into */
    if (!(sptr=malloc((slen+1)*sizeof(char))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
  "Error: failed to allocate space for property name buffer for file id %d",
                *idexo);
        ex_err("exppa",errmsg,EX_MEMFAIL);
      }
    }

    /* Copy property name from Fortran string to staging area */
    ex_fstrncpy(sptr,prop_name,slen);


    /* Use exodusII C routine to store the property values */
    if (ex_put_prop_array (*idexo, (ex_entity_type)*obj_type, sptr, values) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store %s property values in file id %d",
                sptr, *idexo);
        ex_err("exppa",errmsg,EX_MSG);
      }
    }
    free(sptr);
}

/*
 * write node set parameters
 */
% void
% expnp (
%      int *idexo,             /* EXODUS file ID */
%      int *node_set_id,       /* node set ID */
%      int *num_nodes_in_set,  /* number of nodes in the node set */
%      int *num_dist_in_set,   /* number of dist factors in the node set */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_put_node_set_param(*idexo,*node_set_id,
                              *num_nodes_in_set, *num_dist_in_set) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store node set parameters in file id %d",
                *idexo);
        ex_err("expnp",errmsg,EX_MSG);
      }
    }
}

/*
 * read node set parameters
 */
% void
% exgnp (
%      int *idexo,             /* EXODUS file ID */
%      int *node_set_id,       /* node set ID */
%      int *num_nodes_in_set,  /* returned number of nodes in the node set */
%      int *num_dist_in_set,   /* number of dist factors in the node set */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_get_node_set_param(*idexo,*node_set_id,
                              num_nodes_in_set, num_dist_in_set) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get node set parameters from file id %d",
                *idexo);
        ex_err("exgnp",errmsg,EX_MSG);
      }
    }
}

/*
 * write node set
 */
% void
% expns (
%      int *idexo,             /* EXODUS file ID */
%      int *node_set_id,       /* node set ID */
%      int *node_set_node_list,/* node list for the node set */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_put_node_set(*idexo,*node_set_id,node_set_node_list) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store node set in file id %d",
                *idexo);
        ex_err("expns",errmsg,EX_MSG);
      }
    }
}

/*
 * write node set dist factors
 */
% void
% expnsd (
%      int *idexo,             /* EXODUS file ID */
%      int *node_set_id,       /* node set ID */
%      real *node_set_dist_fact, /* distribution factors for the node set */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if(ex_put_node_set_dist_fact(*idexo,*node_set_id, node_set_dist_fact) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store node set dist factors in file id %d",
                *idexo);
        ex_err("expnsd",errmsg,EX_MSG);
      }
    }
}

/*
 * read node set
 */
% void
% exgns (
%      int *idexo,             /* EXODUS file ID */
%      int *node_set_id,       /* node set ID */
%      int *node_set_node_list,/* returned node list for the node set */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_get_node_set(*idexo,*node_set_id,node_set_node_list) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get node set from file id %d",
                *idexo);
        ex_err("exgns",errmsg,EX_MSG);
      }
    }
}

/*
 * read node set dist factors
 */
% void
% exgnsd (
%      int *idexo,             /* EXODUS file ID */
%      int *node_set_id,       /* node set ID */
%      real *node_set_dist_fact, /* returned distribution factors for the */
%                                 /* node set */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if(ex_get_node_set_dist_fact(*idexo,*node_set_id, node_set_dist_fact) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get node set dist factors from file id %d",
                *idexo);
        ex_err("exgnsd",errmsg,EX_MSG);
      }
    }
}


/*
 * read node sets IDs
 */
% void
% exgnsi (
%      int *idexo,             /* EXODUS file ID */
%      int *node_set_ids,      /* returned node set IDs */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_get_node_set_ids(*idexo,node_set_ids) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get node set ids from file id %d",
                *idexo);
        ex_err("exgnsi",errmsg,EX_MSG);
      }
    }
}

/*
 * write concatenated node sets
 */
% void
% expcns (
%      int *idexo,             /* EXODUS file ID */
%      int *node_set_ids,      /* node set ID for each node set */
%      int *num_nodes_per_set, /* number of nodes for each node node set */
%      int *num_dist_per_set,  /* number of dist fact for each node node set */
%      int *node_sets_node_index,/* indices into the node_set_node_list */
%                              /* which are the locations of the first node */
%                              /* for each node set  - 1 based */
%      int *node_sets_dist_index,/* indices into the node_set_dist_fact which */
%                              /* are the locations of the first dist factor */
%                              /* for each node set  - 1 based */
%      int *node_sets_node_list, /* concatenated list of nodes for all the */
%                                /* node sets */
%      real *node_sets_dist_fact, /* concatenated list of distribution factors */
%                                /* for all node sets */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    int num_node_sets, i, *node_index_ptr, *dist_index_ptr;

    *ierr = 0;

    num_node_sets = ex_inquire_int(*idexo,EX_INQ_NODE_SETS);

    /* allocate memory for C node index array */
    if (!(node_index_ptr=malloc(num_node_sets*sizeof(int))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
        "Error: failed to allocate space for node index array for file id %d",
                *idexo);
        ex_err("expcns",errmsg,EX_MEMFAIL);
      }
      return;
    }

    /* allocate memory for C dist factor index array */
    if (!(dist_index_ptr=malloc(num_node_sets*sizeof(int))))
    {
      free(node_index_ptr);
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
        "Error: failed to allocate space for dist index array for file id %d",
                *idexo);
        ex_err("expcns",errmsg,EX_MEMFAIL);
      }
      return;
    }

    for (i=0;i<num_node_sets;i++) /* change from 1-based to 0 index */
    {
      node_index_ptr[i] = node_sets_node_index[i] - 1;
      dist_index_ptr[i] = node_sets_dist_index[i] - 1;
    }

      

    if (ex_put_concat_node_sets(*idexo,node_set_ids,num_nodes_per_set,
                                 num_dist_per_set,node_index_ptr,
                                 dist_index_ptr, node_sets_node_list,
                                 node_sets_dist_fact) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      free(node_index_ptr);
      free(dist_index_ptr);
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store concatenated node sets in file id %d",
                *idexo);
        ex_err("expcns",errmsg,EX_MSG);
      }
      return;
    }
    free(node_index_ptr);
    free(dist_index_ptr);
}

/*
 * read concatenated node sets
 */
% void
% exgcns (
%      int *idexo,             /* EXODUS file ID */
%      int *node_set_ids,      /* node set ID for each node set */
%      int *num_nodes_per_set, /* number of nodes for each node node set */
%      int *num_dist_per_set,  /* number of dist fact for each node node set */
%      int *node_sets_node_index,/* indices into the node_set_node_list */
%                              /* which are the locations of the first node */
%                              /* for each node set  - 1 based */
%      int *node_sets_dist_index,/* indices into the node_set_dist_fact which */
%                              /* are the locations of the first dist factor */
%                              /* for each node set  - 1 based */
%      int *node_sets_node_list, /* concatenated list of nodes for all the */
%                                /* node sets */
%      real *node_sets_dist_fact, /* concatenated list of distribution factors */
%                                /* for all node sets */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    int num_node_sets, i, *node_index_ptr, *dist_index_ptr;

    *ierr = 0;

    num_node_sets = ex_inquire_int(*idexo,EX_INQ_NODE_SETS);

    /* allocate memory for C node  index array */
    if (!(node_index_ptr=malloc(num_node_sets*sizeof(int))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
        "Error: failed to allocate space for node index array for file id %d",
                *idexo);
        ex_err("exgcns",errmsg,EX_MEMFAIL);
      }
      return;
    }

    /* allocate memory for C dist factor index array */
    if (!(dist_index_ptr=malloc(num_node_sets*sizeof(int))))
    {
      free(node_index_ptr);
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
        "Error: failed to allocate space for dist index array for file id %d",
                *idexo);
        ex_err("exgcns",errmsg,EX_MEMFAIL);
      }
      return;
    }

    if (ex_get_concat_node_sets(*idexo,node_set_ids,num_nodes_per_set,
				num_dist_per_set,node_index_ptr,
				dist_index_ptr,node_sets_node_list,
				node_sets_dist_fact) == EX_FATAL)
    {
      free(node_index_ptr);
      free(dist_index_ptr);
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get nodes sets from file id %d",
                *idexo);
        ex_err("exgcns",errmsg,EX_MSG);
      }
      return;
    }

    for (i=0;i<num_node_sets;i++) /* change from 0-based to 1 index */
    {
      node_sets_node_index[i]  = node_index_ptr[i] + 1;
      node_sets_dist_index[i]  = dist_index_ptr[i] + 1;
    }
    
    free(node_index_ptr);
    free(dist_index_ptr);
      
}

/*
 * write side set parameters
 */
% void
% expsp (
%      int *idexo,             /* EXODUS file ID */
%      int *side_set_id,       /* side set ID */
%      int *num_sides_in_set,  /* number of sides in the side set */
%      int *num_df_in_set,     /* number of dist factors in the side set */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_put_side_set_param(*idexo,*side_set_id,*num_sides_in_set,
                                 *num_df_in_set) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store side set parameters in file id %d",
                *idexo);
        ex_err("expsp",errmsg,EX_MSG);
      }
    }
}

/*
 * read side set parameters
 */
% void
% exgsp (
%      int *idexo,             /* EXODUS file ID */
%      int *side_set_id,       /* side set ID */
%      int *num_sides_in_set,  /* returned num of sides in the side set */
%      int *num_df_in_set,     /* returned num of dist factors in the side set*/
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_get_side_set_param(*idexo,*side_set_id,num_sides_in_set,
                                 num_df_in_set) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get side set parameters from file id %d",
                *idexo);
        ex_err("exgsp",errmsg,EX_MSG);
      }
    }
}

/*
 * get side set node list length
 */
% void
% exgsnl (
%      int *idexo,             /* EXODUS file ID */
%      int *side_set_id,       /* side set ID */
%      int *num_nodes_in_set,  /* returned num of sides in the side set */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_get_side_set_node_list_len(*idexo,*side_set_id,
				      num_nodes_in_set) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get side set node list length from file id %d",
                *idexo);
        ex_err("exgsnl",errmsg,EX_MSG);
      }
    }
}

/*
 * write side set
 */
% void
% expss (
%      int *idexo,             /* EXODUS file ID */
%      int *side_set_id,       /* side set ID */
%      int *side_set_elem_list,/* element list for the side set */
%      int *side_set_side_list,/* side list for the side set */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_put_side_set(*idexo,*side_set_id,side_set_elem_list,
                         side_set_side_list) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store side set in file id %d",
                *idexo);
        ex_err("expss",errmsg,EX_MSG);
      }
    }
}

/*
 * read side set
 */
% void
% exgss (
%      int *idexo,             /* EXODUS file ID */
%      int *side_set_id,       /* side set ID */
%      int *side_set_elem_list,/* returned element list for the side set */
%      int *side_set_side_list,/* returned side list for the side set */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_get_side_set(*idexo,*side_set_id,side_set_elem_list,
                         side_set_side_list) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get side set from file id %d",
                *idexo);
        ex_err("exgss",errmsg,EX_MSG);
      }
    }
}

/*
 * write side set distribution factors
 */
% void
% expssd (
%      int *idexo,             /* EXODUS file ID */
%      int *side_set_id,       /* side set ID */
%      real *side_set_dist_fact, /* distribution factors */
%			       /* for the side set */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_put_side_set_dist_fact(*idexo,*side_set_id,
                                   side_set_dist_fact) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
           "Error: failed to store side set distribution factors in file id %d",
                *idexo);
        ex_err("expssd",errmsg,EX_MSG);
      }
    }
}

/*
 * read side set distribution factors
 */
% void
% exgssd (
%      int *idexo,             /* EXODUS file ID */
%      int *side_set_id,       /* side set ID */
%      real *side_set_dist_fact, /* returned distribution factors */
%			       /* for the side set */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_get_side_set_dist_fact(*idexo,*side_set_id,
				   side_set_dist_fact) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
           "Error: failed to get side set distribution factors from file id %d",
                *idexo);
        ex_err("exgssd",errmsg,EX_MSG);
      }
    }
}

/*
 * read side sets IDs
 */
% void
% exgssi (
%      int *idexo,             /* EXODUS file ID */
%      int *side_set_ids,      /* returned side set IDs */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_get_side_set_ids(*idexo,side_set_ids) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get side set ids from file id %d",
                *idexo);
        ex_err("exgssi",errmsg,EX_MSG);
      }
    }
}

/*
 * write concatenated side sets
 */
% void
% expcss (
%      int *idexo,             /* EXODUS file ID */
%      int *side_set_ids,      /* side set ID for each side set */
%      int *num_elem_per_set,  /* number of elements for each side set */
%      int *num_dist_per_set,  /* number of dist factors  for each side set */
%      int *side_sets_elem_index,/* indices into the side_set_elem_list which */
%                                /* are the locations of the first element for*/
%                                /* each side set  - 1 based */
%      int *side_sets_dist_index,/* indices into the side_set_dist_fact which */
%                                /* are the locations of the first node for */
%                                /* each side set  - 1 based */
%      int *side_sets_elem_list, /* concatenated list of elements for all the */
%                                /* side sets */
%      int *side_sets_side_list, /* concatenated list of sides for all the */
%                                /* side sets */
%      real *side_sets_dist_fact, /* concatenated list of distribution */
%                                /* factors for all side sets */
%      int *ierr               /* returned error code */
%      )
% {
  int num_side_sets, i, *elem_index_ptr, *dist_index_ptr;

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;

    if (exoptval & EX_DEBUG) printf("[expcss]\n");

    num_side_sets = ex_inquire_int(*idexo,EX_INQ_SIDE_SETS);

    /* allocate memory for C element index array */
    if (!(elem_index_ptr=malloc(num_side_sets*sizeof(int))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
       "Error: failed to allocate space for element index array for file id %d",
                *idexo);
        ex_err("expcss",errmsg,EX_MEMFAIL);
      }
      return;
    }

    /* allocate memory for C dist factor index array */
    if (!(dist_index_ptr=malloc(num_side_sets*sizeof(int))))
    {
      free(elem_index_ptr);
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
        "Error: failed to allocate space for dist index array for file id %d",
                *idexo);
        ex_err("expcss",errmsg,EX_MEMFAIL);
      }
      return;
    }

    for (i=0;i<num_side_sets;i++) /* change from 1-based to 0 index */
    {
      elem_index_ptr[i] = side_sets_elem_index[i] - 1;
      dist_index_ptr[i] = side_sets_dist_index[i] - 1;
    }

    if (ex_put_concat_side_sets(*idexo,side_set_ids,num_elem_per_set,
                         num_dist_per_set,elem_index_ptr,
                         dist_index_ptr,side_sets_elem_list,
                         side_sets_side_list,side_sets_dist_fact) == EX_FATAL)
    {
      free(elem_index_ptr);
      free(dist_index_ptr);
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store concatenated side sets in file id %d",
                *idexo);
        ex_err("expcss",errmsg,EX_MSG);
      }
      return;
    }
    free(elem_index_ptr);
    free(dist_index_ptr);
}

/*
 * read concatenated side sets
 */
% void
% exgcss (
%      int *idexo,             /* EXODUS file ID */
%      int *side_set_ids,      /* returned side set IDs for each side set */
%      int *num_elem_per_set,  /* returned number of elements for each side */
%                              /* set */
%      int *num_dist_per_set,  /* returned number of nodes for each side set */
%      int *side_sets_elem_index,/* returned indices into the */
%                                /* side_set_elem_list which are the locations*/
%                                /* of the first element for each side set */
%      int *side_sets_dist_index,/* returned indices into the */
%                                /* side_set_node_list which are the locations*/
%                                /* of the first node for each side set */
%      int *side_sets_elem_list, /* returned concatenated list of elements for*/
%                                /* all the side sets */
%      int *side_sets_side_list, /* returned concatenated list of nodes for */
%                                /* all the side sets */
%      real *side_sets_dist_fact, /* returned concatenated list of */
%                                /* distribution factors for all side sets */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];



    int i, num_side_sets, *elem_index_ptr, *dist_index_ptr;

    *ierr = 0;

    num_side_sets = ex_inquire_int(*idexo,EX_INQ_SIDE_SETS);

    /* allocate memory for C elem index array */
    if (!(elem_index_ptr=malloc(num_side_sets*sizeof(int))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
       "Error: failed to allocate space for element index array for file id %d",
                *idexo);
        ex_err("exgcss",errmsg,EX_MEMFAIL);
      }
      return;
    }

    /* allocate memory for C dist factor index array */
    if (!(dist_index_ptr=malloc(num_side_sets*sizeof(int))))
    {
      free(elem_index_ptr);
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
        "Error: failed to allocate space for dist index array for file id %d",
                *idexo);
        ex_err("exgcss",errmsg,EX_MEMFAIL);
      }
      return;
    }

/*    printf("[exgcss] calling ex_get_side_set ...\n");
    printf("[exgcss] loc side_set_ids: %ld\n",side_set_ids);
    printf("[exgcss] loc num_elem_per_set: %ld\n",num_elem_per_set);
    printf("[exgcss] loc num_nodes_per_set: %ld\n",num_nodes_per_set);
    printf("[exgcss] loc side_sets_node_index: %ld\n",side_sets_node_index);
    printf("[exgcss] loc side_sets_elem_index: %ld\n",side_sets_elem_index);
    printf("[exgcss] loc side_sets_node_list: %ld\n",side_sets_node_list);
    printf("[exgcss] loc side_sets_elem_list: %ld\n",side_sets_elem_list);
    printf("[exgcss] loc side_sets_dist_fact: %ld\n",side_sets_dist_fact); */

    if (ex_get_concat_side_sets(*idexo,side_set_ids,num_elem_per_set,
                         num_dist_per_set,elem_index_ptr,
                         dist_index_ptr,side_sets_elem_list,
                         side_sets_side_list,side_sets_dist_fact) == EX_FATAL)
    {
      free (elem_index_ptr);
      free (dist_index_ptr);
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get concatenated side sets from file id %d",
                *idexo);
        ex_err("exgcss",errmsg,EX_MSG);
      }
      return;
    }

    for (i=0;i<num_side_sets;i++) /* change from 0-based to 1 index */
    {
      side_sets_elem_index[i] = elem_index_ptr[i] + 1;
      side_sets_dist_index[i] = dist_index_ptr[i] + 1;
/* First walk element index array */
  /*  printf("[exgcss] # of elem per side set[%d]: %d\n",i,num_elem_per_set[i]);
      printf("[exgcss] elem index[%d]: %d\n",i,side_sets_elem_index[i]); */
/* Then walk node index array */
  /*  printf("[exgcss] # of nodes per side set: %d\n",num_nodes_per_set[i]);
      printf("[exgcss] node index[%d]: %d\n",i,side_sets_node_index[i]); */
    }
    free (elem_index_ptr);
    free (dist_index_ptr);
}

/*
 * read concatenated side sets (no dist factors)
 */
% void
% exgcssf (
%      int *idexo,             /* EXODUS file ID */
%      int *side_set_ids,      /* returned side set IDs for each side set */
%      int *num_elem_per_set,  /* returned number of elements for each side */
%                              /* set */
%      int *num_dist_per_set,  /* returned number of nodes for each side set */
%      int *side_sets_elem_index,/* returned indices into the */
%                                /* side_set_elem_list which are the locations*/
%                                /* of the first element for each side set */
%      int *side_sets_dist_index,/* returned indices into the */
%                                /* side_set_node_list which are the locations*/
%                                /* of the first node for each side set */
%      int *side_sets_elem_list, /* returned concatenated list of elements for*/
%                                /* all the side sets */
%      int *side_sets_side_list, /* returned concatenated list of nodes for */
%                                /* all the side sets */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];



    int i, num_side_sets, *elem_index_ptr, *dist_index_ptr;

    *ierr = 0;

    num_side_sets = ex_inquire_int(*idexo,EX_INQ_SIDE_SETS);

    /* allocate memory for C elem index array */
    if (!(elem_index_ptr=malloc(num_side_sets*sizeof(int))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
       "Error: failed to allocate space for element index array for file id %d",
                *idexo);
        ex_err("exgcss",errmsg,EX_MEMFAIL);
      }
      return;
    }

    /* allocate memory for C dist factor index array */
    if (!(dist_index_ptr=malloc(num_side_sets*sizeof(int))))
    {
      free(elem_index_ptr);
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
        "Error: failed to allocate space for dist index array for file id %d",
                *idexo);
        ex_err("exgcss",errmsg,EX_MEMFAIL);
      }
      return;
    }

    if (ex_get_concat_side_sets(*idexo,side_set_ids,num_elem_per_set,
                         num_dist_per_set,elem_index_ptr,
                         dist_index_ptr,side_sets_elem_list,
                         side_sets_side_list,0) == EX_FATAL)
    {
      free (elem_index_ptr);
      free (dist_index_ptr);
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get concatenated side sets from file id %d",
                *idexo);
        ex_err("exgcss",errmsg,EX_MSG);
      }
      return;
    }

    for (i=0;i<num_side_sets;i++) /* change from 0-based to 1 index */
    {
      side_sets_elem_index[i] = elem_index_ptr[i] + 1;
      side_sets_dist_index[i] = dist_index_ptr[i] + 1;
    }
    free (elem_index_ptr);
    free (dist_index_ptr);
}

/*
 * write results variables parameters
 */
% void
% expvp (
%      int *idexo,             /* EXODUS file ID */
%      string var_type,        /* (single) character indicating the type of */
%                              /* variable which is described */
%      int *num_vars,          /* number of var_type variables */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_put_var_param(*idexo,var_type,*num_vars) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
            "Error: failed to store results variables parameters in file id %d",
                *idexo);
        ex_err("expvp",errmsg,EX_MSG);
      }
    }
}

/*
 * read results variables parameters
 */
% void
% exgvp (
%      int *idexo,             /* EXODUS file ID */
%      string var_type,        /* (single) character indicating the type of */
%                              /* variable which is described */
%      int *num_vars,          /* returned number of var_type variables */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_get_var_param(*idexo,var_type,num_vars) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
            "Error: failed to get results variables parameters from file id %d",
                *idexo);
        ex_err("exgvp",errmsg,EX_MSG);
      }
    }
    /** if (exoptval & EX_DEBUG) 
        printf("[exgvp] # of vars for type %c: %d\n",
                         *var_type,*num_vars); **/
}

/*
 * write results variables names
 */
% void
% expvan (
%      int *idexo,             /* EXODUS file ID */
%      string var_type,        /* (single) character indicating the type of */
%                              /* variables which is described */
%      int *num_vars,          /* number of var_type variables to be written */
%      string var_names,       /* string containing num_vars variable names */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    char **aptr;/* ptr to temp staging space for string array ptrs */
    char *sptr; /* ptr to temp staging space for strings */
    int i,slen;

    *ierr=0;     /* default no errror */

    slen = ex_inquire_int(*idexo, EX_INQ_DB_MAX_ALLOWED_NAME_LENGTH);	/* max str size */
    if (var_nameslen < slen)
    {
      slen = var_nameslen;
    }

    /* allocate memory for pointer array */
    if (!(aptr=malloc((*num_vars+1)*sizeof(char *))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
  "Error: failed to allocate space for variable names ptr array for file id %d",
                *idexo);
        ex_err("expvan",errmsg,EX_MEMFAIL);
      }
      return;
    }

    /* Allocate staging space for the variable names */
    if (!(sptr=malloc(*num_vars*(slen+1)*sizeof(char))))
    { 
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
     "Error: failed to allocate space for variable names buffer for file id %d",
                *idexo);
        ex_err("expvan",errmsg,EX_MEMFAIL);
      }
      free(aptr);        /* Free up string ptr array */	
      *ierr = EX_MEMFAIL;
      return;
    }
    /* Copy Fortran variable names to staging space */
    for (i=0;i<*num_vars;i++)
    {
      *(aptr+i) = sptr+i*(slen+1);		/* put address into ptr array */
      ex_fstrncpy(*(aptr+i),var_names+i*var_nameslen,slen);/* copy string into buffer */
    }
    *(aptr+i) = 0; /* null out last ptr */
    /* do ExodusII C call to write results variables names */
    if (ex_put_var_names(*idexo,var_type,*num_vars,aptr) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store results variables names in file id %d",
                *idexo);
        ex_err("expvan",errmsg,EX_MSG);
      }
    }

    free(sptr);	/* Free up string staging area */
    free(aptr);        /* Free up string ptr array */	
}
/*
 * read results variables names
 */
% void
% exgvan (
%      int *idexo,             /* EXODUS file ID */
%      string var_type,        /* (single) character indicating the type of */
%                              /* variable which is described */
%      int *num_vars,          /* number of var_type variables to be read */
%      string var_names,       /* returned string containing num_vars variable*/
%                              /* names */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    char **aptr;/* ptr to temp staging space for string array ptrs */
    char *sptr; /* ptr to temp staging space for strings */
    int i,slen;

    *ierr=0;     /* default no errror */

    /**if (exoptval & EX_DEBUG) 
	printf("[exgvan] # of variable names: %d\n",*num_vars); **/

    slen = ex_max_name_length;	/* max str size */
    if (var_nameslen < slen)
    {
      slen = var_nameslen;
    }

    /* allocate memory to for pointer array */
    if (!(aptr=malloc((*num_vars+1)*sizeof(char *))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
                "Error: failed to allocate space for results variable names ptr array for file id %d",
                *idexo);
        ex_err("exgvan",errmsg,EX_MEMFAIL);
      }
      return;
    }

    /* Allocate staging space for the variable names */
    if (!(sptr=malloc(*num_vars*(slen+1)*sizeof(char))))
    { 
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
    "Error: failed to allocate space for results variable names for file id %d",
                *idexo);
        ex_err("exgvan",errmsg,EX_MEMFAIL);
      }
      free(aptr);        /* Free up string ptr array */	
      return;
    }
    for (i=0;i<*num_vars;i++)
      *(aptr+i) = sptr+i*(slen+1);              /* put address into ptr array */
    *(aptr+i) = 0; /* null out last ptr */

    /* do ExodusII C call to read results variables names */
    if (ex_get_var_names(*idexo,var_type,*num_vars,aptr) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      free(sptr);	/* free up allocated space */  
      free(aptr);
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get results variable names from file id %d",
                *idexo);
        ex_err("exgvan",errmsg,EX_MSG);
      }
      return;
    }

    /* Copy Fortran variable names to staging space */
    memset(var_names, 0, *num_vars*var_nameslen);
    for (i=0;i<*num_vars;i++)
    {
      /** printf("[exgvan] var_name(%d): %s\n",i,*(aptr+i)); **/
      ex_fcdcpy(var_names+i*var_nameslen,slen,*(aptr+i));/* copy str into Fortran buffer */
    }

    free(sptr);	/* Free up string staging area */
    free(aptr);        /* Free up string ptr array */	
}

/*
 * write element variable truth table
 */
% void
% expvtt (
%      int *idexo,             /* EXODUS file ID */
%      int *num_elem_blk,      /* number of element blocks */
%      int *num_elem_var,      /* number of element variables */
%      int *elem_var_tab,      /* element variable truth table 2D array */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];



    /** printf("[expvtt] # elem blks: %d, # elem vars: %d\n",
                       *num_elem_blk,*num_elem_var); **/
    *ierr = 0;

    if (ex_put_elem_var_tab(
          *idexo,*num_elem_blk,*num_elem_var,elem_var_tab) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
            "Error: failed to store element variable truth table in file id %d",
                *idexo);
        ex_err("expvtt",errmsg,EX_MSG);
      }
      return;
    }
}

/*
 * write nodeset variable truth table
 */
% void
% expnstt (
%      int *idexo,             /* EXODUS file ID */
%      int *num_entity,        /* number of entity  blocks */
%      int *num_var,           /* number of variables */
%      int *var_tab,           /* entity variable truth table 2D array */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];

    *ierr = 0;

    if (ex_put_nset_var_tab(
          *idexo,*num_entity,*num_var,var_tab) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
            "Error: failed to store nodeset variable truth table in file id %d",
                *idexo);
        ex_err("expnstt",errmsg,EX_MSG);
      }
      return;
    }
}

/*
 * write sideset variable truth table
 */
% void
% expsstt (
%      int *idexo,             /* EXODUS file ID */
%      int *num_entity,        /* number of entity  blocks */
%      int *num_var,           /* number of variables */
%      int *var_tab,           /* entity variable truth table 2D array */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];

    *ierr = 0;

    if (ex_put_sset_var_tab(
          *idexo,*num_entity,*num_var,var_tab) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
            "Error: failed to store sideset variable truth table in file id %d",
                *idexo);
        ex_err("expsstt",errmsg,EX_MSG);
      }
      return;
    }
}

/*
 * read element variable truth table
 */
% void
% exgvtt (
%      int *idexo,             /* EXODUS file ID */
%      int *num_elem_blk,      /* number of element blocks */
%      int *num_elem_var,      /* number of element variables */
%      int *elem_var_tab,      /* returned element variable truth table array */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;

    if (ex_get_elem_var_tab(
          *idexo,*num_elem_blk,*num_elem_var,elem_var_tab) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
  "Error: failed to failed to get element variable truth table from file id %d",
                *idexo);
        ex_err("exgvtt",errmsg,EX_MSG);
      }
      return;
    }
}

/*
 * read nodeset variable truth table
 */
% void
% exgnstt (
%      int *idexo,             /* EXODUS file ID */
%      int *num_entity,        /* number of entity blocks */
%      int *num_var,           /* number of variables */
%      int *var_tab,           /* returned variable truth table array */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;

    if (ex_get_nset_var_tab(
          *idexo,*num_entity,*num_var,var_tab) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
  "Error: failed to failed to get nodeset variable truth table from file id %d",
                *idexo);
        ex_err("exgnstt",errmsg,EX_MSG);
      }
      return;
    }
}

/*
 * read sideset variable truth table
 */
% void
% exgsstt (
%      int *idexo,             /* EXODUS file ID */
%      int *num_entity,        /* number of entity blocks */
%      int *num_var,           /* number of variables */
%      int *var_tab,           /* returned variable truth table array */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;

    if (ex_get_sset_var_tab(
          *idexo,*num_entity,*num_var,var_tab) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
  "Error: failed to failed to get sideset variable truth table from file id %d",
                *idexo);
        ex_err("exgsstt",errmsg,EX_MSG);
      }
      return;
    }
}

/*
 * write global variable values at time step
 */
% void
% expgv (
%      int *idexo,             /* EXODUS file ID */
%      int *time_step,         /* time step number */
%      int *num_glob_vars,     /* number of global variables */
%      real *glob_var_vals,   /* array of global variable values */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];

    *ierr = 0;
    if (ex_put_glob_vars(*idexo,*time_step,*num_glob_vars,glob_var_vals) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store global variables in file id %d",
                *idexo);
        ex_err("expvg",errmsg,EX_MSG);
      }
    }
}

/*
 * read global variable values at a time step
 */
% void
% exggv (
%      int *idexo,             /* EXODUS file ID */
%      int *time_step,         /* time step number */
%      int *num_glob_vars,     /* number of global variables */
%      real *glob_var_vals,   /* returned array of global variable values */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];

    *ierr = 0;
    if (ex_get_glob_vars(*idexo,*time_step,*num_glob_vars,glob_var_vals) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get global variables from file id %d",
                *idexo);
        ex_err("exggv",errmsg,EX_MSG);
      }

    }
}

/*
 * read global variable values through time
 */
% void
% exggvt (
%      int *idexo,             /* EXODUS file ID */
%      int *glob_var_index,    /* index of desired global variable */
%      int *beg_time_step,     /* first time step for which value is desired */
%      int *end_time_step,     /* last time step for which value is desired */
%      real *glob_var_vals,   /* returned array of global variable values */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_get_glob_var_time(*idexo,
                             *glob_var_index,
                             *beg_time_step,
                             *end_time_step,
                             glob_var_vals) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
              "Error: failed to get global variables thru time from file id %d",
                *idexo);
        ex_err("exggvt",errmsg,EX_MSG);
      }

    }
}

/*
 * write nodal variable values at a time step
 */
% void
% expnv (
%      int *idexo,             /* EXODUS file ID */
%      int *time_step,         /* time step number */
%      int *nodal_var_index,   /* index of nodal variable */
%      int *num_nodes,         /* number of nodal points */
%      real *nodal_var_vals,  /* array of nodal variable values */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_put_nodal_var(*idexo,
                         *time_step,
                         *nodal_var_index,
                         *num_nodes,
                         nodal_var_vals) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store nodal variables in file id %d",
                *idexo);
        ex_err("expnv",errmsg,EX_MSG);
      }
    }
}

/*
 * read nodal variable values at a time step
 */
% void
% exgnv (
%      int *idexo,             /* EXODUS file ID */
%      int *time_step,         /* time step number */
%      int *nodal_var_index,   /* index of nodal variable */
%      int *num_nodes,         /* number of nodal points */
%      real *nodal_var_vals,  /* returned array of nodal variable values */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_get_nodal_var(*idexo,
                         *time_step,
                         *nodal_var_index,
                         *num_nodes,
                         nodal_var_vals) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
         "Error: failed to get nodal variables at time step %d from file id %d",
                *time_step,*idexo);
        ex_err("exgnv",errmsg,EX_MSG);
      }
    }
}

/*
 * read nodal variable values through time
 */
% void
% exgnvt (
%      int *idexo,             /* EXODUS file ID */
%      int *nodal_var_index,   /* index of nodal variable */
%      int *node_number,       /* number of desired node */
%      int *beg_time_step,     /* first time step for which value is desired */
%      int *end_time_step,     /* last time step for which value is desired */
%      real *nodal_var_vals,  /* returned array of nodal variable values */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_get_nodal_var_time(*idexo,
                             *nodal_var_index,
                             *node_number,
                             *beg_time_step,
                             *end_time_step,
                             nodal_var_vals) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get nodal variables thru time from file id %d",
                *idexo);
        ex_err("exgnvt",errmsg,EX_MSG);
      }
    }
}

/*
 * write element variable values at a time step
 */
% void
% expev (
%      int *idexo,             /* EXODUS file ID */
%      int *time_step,         /* time step number */
%      int *elem_var_index,    /* index of element variable */
%      int *elem_blk_id,       /* element block ID */
%      int *num_elem_this_blk, /* number of elements in this element block */
%      real *elem_var_vals,   /* array of element variable values */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_put_elem_var(*idexo,
                        *time_step,
                        *elem_var_index,
                        *elem_blk_id,
                        *num_elem_this_blk,
                        elem_var_vals) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store element variables in file id %d",
                *idexo);
        ex_err("expev",errmsg,EX_MSG);
      }
    }
}

/*
 * read element variable values at a time step
 */
% void
% exgev (
%      int *idexo,             /* EXODUS file ID */
%      int *time_step,         /* time step number */
%      int *elem_var_index,    /* index of element variable */
%      int *elem_blk_id,       /* element block ID */
%      int *num_elem_this_blk, /* number of elements in this element block */
%      real *elem_var_vals,   /* returned array of element variable values */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_get_elem_var(*idexo,
                        *time_step,
                        *elem_var_index,
                        *elem_blk_id,
                        *num_elem_this_blk,
                        elem_var_vals) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get element variables from file id %d",
                *idexo);
        ex_err("exgev",errmsg,EX_MSG);
      }

      if (exoptval & EX_DEBUG)
        ex_err("exgev"," error reading element variables",EX_MSG);
    }
}

/*
 * read element variable values through time
 */
% void
% exgevt (
%      int *idexo,             /* EXODUS file ID */
%      int *elem_var_index,    /* index of element variable */
%      int *elem_number,       /* number of desired element */
%      int *beg_time_step,     /* first time step for which value is desired */
%      int *end_time_step,     /* last time step for which value is desired */
%      real *elem_var_vals,   /* returned element variable values */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_get_elem_var_time(*idexo,
                             *elem_var_index,
                             *elem_number,
                             *beg_time_step,
                             *end_time_step,
                             elem_var_vals) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
             "Error: failed to get element variables thru time from file id %d",
                *idexo);
        ex_err("exgevt",errmsg,EX_MSG);
      }
    }
}

/*
 * write nodeset variable values at a time step
 */
% void
% expnsv (
%      int *idexo,             /* EXODUS file ID */
%      int *time_step,         /* time step number */
%      int *var_index,         /* index of variable */
%      int *entity_id,         /* entity ID */
%      int *num_entity,        /* number of entities in this entity block */
%      real *var_vals,         /* array of variable values */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_put_nset_var(*idexo,
                        *time_step,
                        *var_index,
                        *entity_id,
                        *num_entity,
                        var_vals) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store nodeset variables in file id %d",
                *idexo);
        ex_err("expnsv",errmsg,EX_MSG);
      }
    }
}

/*
 * read nodeset variable values at a time step
 */
% void
% exgnsv (
%      int *idexo,             /* EXODUS file ID */
%      int *time_step,         /* time step number */
%      int *var_index,         /* index of variable */
%      int *entity_id,         /* entity ID */
%      int *num_entity,        /* number of entities in this entity block */
%      real *var_vals,         /* returned array of variable values */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_get_nset_var(*idexo,
                        *time_step,
                        *var_index,
                        *entity_id,
                        *num_entity,
                        var_vals) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get nodeset variables from file id %d",
                *idexo);
        ex_err("exgnsv",errmsg,EX_MSG);
      }

      if (exoptval & EX_DEBUG)
        ex_err("exgnsv"," error reading nodeset variables",EX_MSG);
    }
}

/*
 * write sideset variable values at a time step
 */
% void
% expssv (
%      int *idexo,             /* EXODUS file ID */
%      int *time_step,         /* time step number */
%      int *var_index,         /* index of variable */
%      int *entity_id,         /* entity ID */
%      int *num_entity,        /* number of entities in this entity block */
%      real *var_vals,         /* array of variable values */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_put_sset_var(*idexo,
                        *time_step,
                        *var_index,
                        *entity_id,
                        *num_entity,
                        var_vals) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store sideset variables in file id %d",
                *idexo);
        ex_err("expssv",errmsg,EX_MSG);
      }
    }
}

/*
 * read sideset variable values at a time step
 */
% void
% exgssv (
%      int *idexo,             /* EXODUS file ID */
%      int *time_step,         /* time step number */
%      int *var_index,         /* index of variable */
%      int *entity_id,         /* entity ID */
%      int *num_entity,        /* number of entities in this entity block */
%      real *var_vals,         /* returned array of variable values */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_get_sset_var(*idexo,
                        *time_step,
                        *var_index,
                        *entity_id,
                        *num_entity,
                        var_vals) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get sideset variables from file id %d",
                *idexo);
        ex_err("exgssv",errmsg,EX_MSG);
      }

      if (exoptval & EX_DEBUG)
        ex_err("exgssv"," error reading sideset variables",EX_MSG);
    }
}

/*
 * write time value for a time step
 */
% void
% exptim (
%      int *idexo,             /* EXODUS file ID */
%      int *time_step,         /* the time step number */
%      real *time_value,      /* simulation time value */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_put_time(*idexo,*time_step,time_value) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store time step value in file id %d",
                *idexo);
        ex_err("exptim",errmsg,EX_MSG);
      }
    }
}

/*
 * read time value for a time step
 */
% void
% exgtim (
%      int *idexo,             /* EXODUS file ID */
%      int *time_step,         /* the time step number */
%      real *time_value,      /* returned simulation time value */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_get_time(*idexo,*time_step,time_value) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get time step value from file id %d",
                *idexo);
        ex_err("exgtim",errmsg,EX_MSG);
      }
    }
}

/*
 * read all time values
 */
% void
% exgatm (
%      int *idexo,             /* EXODUS file ID */
%      real *time_values,     /* returned simulation time values */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_get_all_times(*idexo,time_values) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get time step values from file id %d",
                *idexo);
        ex_err("exgatm",errmsg,EX_MSG);
      }
    }
}

/*
 * inquire EXODUS parameters
 */
% void
% exinq (
%      int *idexo,             /* EXODUS file ID */
%      int *req_info,          /* flag designating what information is */
%                              /* requested */
%      int *ret_int,           /* returned integer, if integer value requested*/
%      float *ret_float,       /* returned real, if real value requested */
%      string ret_char,        /* returned string, if string value requested */
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];



    *ierr = 0;
    if (ex_inquire(*idexo,(ex_inquiry)*req_info,ret_int,ret_float,ret_char) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get requested parameter from file id %d",
                *idexo);
        ex_err("exinq",errmsg,EX_MSG);
      }
    }
}

/*
 * convert side set node lists to side set side lists
 */
% void
% excn2s(
%      int *idexo,                /* EXODUS file ID */
%      int *num_elem_per_set,     /* number of element per set
%      int *num_nodes_per_set,    /* number of nodes per set
%      int *side_sets_elem_index, /* index array of elements into elem list
%      int *side_sets_node_index, /* index array of nodes
%      int *side_sets_elem_list,  /* array of elements
%      int *side_sets_node_list,  /* array of nodes
%      int *side_sets_side_list,  /* array of sides/faces
%      int *ierr                  /* returned error code */
%      )
% {

    int i, num_side_sets, *node_index_ptr, *elem_index_ptr;

  char errmsg[MAX_ERR_LENGTH];

    *ierr = 0;

    num_side_sets = ex_inquire_int(*idexo,EX_INQ_SIDE_SETS);

    /* allocate memory for C element index array */
    if (!(elem_index_ptr=malloc(num_side_sets*sizeof(int))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
       "Error: failed to allocate space for element index array for file id %d",
                *idexo);
        ex_err("excn2s",errmsg,EX_MEMFAIL);
      }
      return;
    }

    /* allocate memory for C node factor index array */
    if (!(node_index_ptr=malloc(num_side_sets*sizeof(int))))
    {
      free(elem_index_ptr);
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
        "Error: failed to allocate space for node index array for file id %d",
                *idexo);
        ex_err("excn2s",errmsg,EX_MEMFAIL);
      }
      return;
    }
    /* change from 1-based to 0 index */
    for (i=0;i<num_side_sets;i++)
    {
      elem_index_ptr[i] = side_sets_elem_index[i] - 1;
      node_index_ptr[i] = side_sets_node_index[i] - 1;
    }

    if (ex_cvt_nodes_to_sides(*idexo,
			      num_elem_per_set,
			      num_nodes_per_set,
			      elem_index_ptr,
			      node_index_ptr,
			      side_sets_elem_list,
			      side_sets_node_list,
			      side_sets_side_list) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to convert nodes to sides in file id %d",
                *idexo);
        ex_err("excn2s",errmsg,EX_MSG);
      }
    }
    free(elem_index_ptr);
    free(node_index_ptr);
}

/*
 * read side set node list
 */
% void
% exgssn(
%      int *idexo,                /* EXODUS file ID */
%      int *side_set_id,          /* side set ID */
%      int *side_set_node_cnt_list,/* array of node counts */
%      int *side_set_node_list,   /* array of nodes */
%      int *ierr                  /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];

    *ierr = 0;

    if (ex_get_side_set_node_list(*idexo,*side_set_id, side_set_node_cnt_list,
                                  side_set_node_list) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get nodes for side set %d in file id %d",
                *side_set_id, *idexo);
        ex_err("exgssn",errmsg,EX_MSG);
      }
    }
}

/*
 * read side set node count
 */
% void
% exgssc(
%      int *idexo,                /* EXODUS file ID */
%      int *side_set_id,          /* side set ID */
%      int *side_set_node_cnt_list,/* array of node counts */
%      int *ierr                  /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];

    *ierr = 0;

    if (ex_get_side_set_node_count(*idexo,*side_set_id, side_set_node_cnt_list) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get node counts for side set %d in file id %d",
                *side_set_id, *idexo);
        ex_err("exgssc",errmsg,EX_MSG);
      }
    }
}

/*
 * read concatenated side set node count
 */
% void
% exgcssc(
%      int *idexo,                /* EXODUS file ID */
%      int *side_set_node_cnt_list,/* array of node counts */
%      int *ierr                  /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];

    *ierr = 0;

    if (ex_get_concat_side_set_node_count(*idexo, side_set_node_cnt_list) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get node counts for side sets in file id %d", *idexo);
        ex_err("exgcssc",errmsg,EX_MSG);
      }
    }
}

/* ex_get_coordinate_frames -- read coordinate frames */
% void
% exgfrm (
%    int  *idexo,
%    int  *nframeo,
%    int  *cfids,
%    real *coord,
%    int  *tags,
%    int  *ierr
%    )
% {
  int i;
  char *ctags = NULL;

  char errmsg[MAX_ERR_LENGTH];

  /* Determine number of coordinate frames stored in file */
  int nframe = ex_inquire_int(*idexo, EX_INQ_COORD_FRAMES);

  if (nframe != *nframeo) {
     *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG) {
	sprintf(errmsg,
		"Error: nframe argument (%d) does not match number found on file (%d) from file id %d",
		*nframeo, nframe, *idexo);
	ex_err("exgfrm",errmsg,EX_MSG);
      }
    return;
  }

  /* Create array of characters to store tags... */
  if (nframe > 0) {
    if (!(ctags = calloc(nframe, sizeof(char)))) {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG) {
	sprintf(errmsg,
		"Error: failed to allocate space for node index array for file id %d",
		*idexo);
	ex_err("exgfrm",errmsg,EX_MEMFAIL);
      }
      return;
    }

    *ierr = 0;
    
    if (ex_get_coordinate_frames (*idexo, &nframe, cfids, coord, ctags) == EX_FATAL) {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG) {
	sprintf(errmsg,
		"Error: failed to get coordinate frames from file id %d",
		*idexo);
	ex_err("exgfrm",errmsg,EX_MSG);
      }
      return;
    }

    /* Convert character tags back to integer tags for fortran */
    for (i = 0; i < nframe; i++) {
      if (ctags[i] == 'R' || ctags[i] == 'r')
	tags[i] = EX_CF_RECTANGULAR;
      else if (ctags[i] == 'C' || ctags[i] == 'c')
	tags[i] = EX_CF_CYLINDRICAL;
      else if (ctags[i] == 'S' || ctags[i] == 's')
	tags[i] = EX_CF_SPHERICAL;
    }
    free(ctags);
  }
}

/* ex_put_coordinate_frames -- define/write coordinate frames */
% void
% expfrm (
%    int  *idexo,
%    int  *nframe,
%    int  *cfids,
%    real *coord,
%    int  *tags,
%    int  *ierr
%    )
% {
  int i;
  char *ctags = NULL;

  char errmsg[MAX_ERR_LENGTH];

  /* Create array of characters to store tags... */
  if (*nframe > 0) {
    if (!(ctags = calloc(*nframe, sizeof(char)))) {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG) {
	sprintf(errmsg,
		"Error: failed to allocate space for node index array for file id %d",
		*idexo);
	ex_err("exgfrm",errmsg,EX_MEMFAIL);
      }
      return;
    }

    /* Convert fortran integer tags to C API character tags */
    for (i = 0; i < *nframe; i++) {
      if (tags[i] == EX_CF_RECTANGULAR)
	ctags[i] = 'R';
      else if (tags[i] == EX_CF_CYLINDRICAL)
        ctags[i] = 'C';
      else if (tags[i] == EX_CF_SPHERICAL)
        ctags[i] = 'S';
    }

    *ierr = 0;

    if (ex_put_coordinate_frames (*idexo, *nframe, cfids, coord, ctags) == EX_FATAL) {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG) {
	sprintf(errmsg,
		"Error: failed to define/write coordinate frames in file id %d",
		*idexo);
	ex_err("expfrm",errmsg,EX_MSG);
      }
      return;
    }

    free(ctags);
  }
}


/* Routine to return floating point word size */
% int 
% excpws ()
% {
  return (ex_get_cpu_ws());
}

/* Routine to return large model setting */
% int 
% exlgmd (
%      int *idexo
%      )
% {
  return (ex_large_model(*idexo));
}


/* Generalized error handling function */
% void
% exerr (
%      string pname,            /* procedure name */
%      string err_string,	/* error message string */
%      int *errcode             /* error code */
%      )
% {

    char *proc_name, *error_string;
    if (!(proc_name = malloc((pnamelen+1)*sizeof(char))))
    {
      ex_err("exerr","Error: failed to allocate space for process name buffer",
              EX_MEMFAIL);
      return;
    }
    if (!(error_string = malloc((err_stringlen+1)*sizeof(char))))
    {
      free(proc_name);
      ex_err("exerr","Error: failed to allocate space for error msg buffer",
              EX_MEMFAIL);
      return;
    }
    ex_fstrncpy(proc_name,pname,pnamelen);
    ex_fstrncpy(error_string,err_string,err_stringlen);
    ex_err(proc_name,error_string,*errcode);
    free(proc_name);
    free(error_string);
}

/* Error message reporting options setting function */
% void
% exopts (
%      int *option_val		/* option value */
%      int *ierr                /* error return code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];

  *ierr = 0;
  ex_opts((ex_options)*option_val);
  if (exerrval != 0)
  {
    *ierr = EX_FATAL;
    if (exoptval & EX_DEBUG)
    {
      sprintf(errmsg,
             "Error: failed to set error reporting option to %d",
              *option_val);
      ex_err("exopts",errmsg,EX_MSG);
    }
  }
}

% void
% exmxnm (
%      int *idexo,       /* EXODUS file ID */
%      int *length,	/* max length of names */
%      int *ierr        /* error return code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];

  *ierr = ex_set_max_name_length(*idexo, *length);
  if (*ierr != 0)
  {
    *ierr = EX_FATAL;
    if (exoptval & EX_DEBUG)
    {
      sprintf(errmsg,
             "Error: failed to set maximum name length to %d",
              *length);
      ex_err("exmxnm",errmsg,EX_MSG);
    }
  }
}

/*
 * copy EXODUS file
 */
% void
% excopy (
%      int *idexo_in,            /* input EXODUS file ID */
%      int *idexo_out,           /* output EXODUS file ID */
%      int *ierr                 /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_copy (*idexo_in, *idexo_out) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to copy EXODUS file id %d to file id %d",
                *idexo_in, *idexo_out);
        ex_err("excopy",errmsg,EX_MSG);
      }
    }
}

/*
 * get element map
 */
% void
% exgem (
%      int *idexo,            /* EXODUS file ID */
%      int *map_id,           /* element map ID */
%      int *elem_map,         /* returned element map */
%      int *ierr              /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    *ierr = ex_get_elem_map (*idexo, *map_id, elem_map);
    if (*ierr < 0)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get element map from file id %d",
                *idexo);
        ex_err("exgem",errmsg,EX_MSG);
      }
    }
}
/*
 * get partial_element map
 */
% void
% exgpem (
%      int *idexo,            /* EXODUS file ID */
%      int *map_id,           /* element map ID */
%      int *start,            /* starting entity */
%      int *count,            /* number to read */
%      int *elem_map,         /* returned element map */
%      int *ierr              /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    *ierr = ex_get_partial_elem_map (*idexo, *map_id, *start, *count, elem_map);
    if (*ierr < 0)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get partial element map from file id %d",
                *idexo);
        ex_err("exgem",errmsg,EX_MSG);
      }
    }
}

/*
 * get element number map
 */
% void
% exgenm (
%      int *idexo,            /* EXODUS file ID */
%      int *elem_map,         /* returned element order map */
%      int *ierr              /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    *ierr = ex_get_elem_num_map (*idexo, elem_map);
    if (*ierr < 0)
/*    if (ex_get_elem_num_map (*idexo, elem_map) == -1) */
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get element number map from file id %d",
                *idexo);
        ex_err("exgenm",errmsg,EX_MSG);
      }
    }
}

/*
 * get map parameters
 */
% void
% exgmp (
%      int *idexo,            /* EXODUS file ID */
%      int *num_node_maps,    /* returned number of node maps */
%      int *num_elem_maps,    /* returned number of element maps */
%      int *ierr              /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    *ierr = ex_get_map_param (*idexo, num_node_maps, num_elem_maps);
    if (*ierr < 0)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get map parameters from file id %d",
                *idexo);
        ex_err("exgmp",errmsg,EX_MSG);
      }
    }
}

/*
 * get node map
 */
% void
% exgnm (
%      int *idexo,            /* EXODUS file ID */
%      int *map_id,           /* node map ID */
%      int *node_map,         /* returned node map */
%      int *ierr              /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    *ierr = ex_get_node_map (*idexo, *map_id, node_map);
    if (*ierr < 0)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get node map from file id %d",
                *idexo);
        ex_err("exgem",errmsg,EX_MSG);
      }
    }
}

/*
 * get node number map
 */
% void
% exgnnm (
%      int *idexo,            /* EXODUS file ID */
%      int *node_map,         /* returned node order map */
%      int *ierr              /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    *ierr = ex_get_node_num_map (*idexo, node_map);
    if (*ierr < 0) 
/*    if (ex_get_node_num_map (*idexo, node_map) == -1) */
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get node number map from file id %d",
                *idexo);
        ex_err("exgnnm",errmsg,EX_MSG);
      }
    }
}

/*
 * read results variables names
 */
% void
% exgvnm (
%      int *idexo,             /* EXODUS file ID */
%      string var_type,        /* (single) character indicating the type of */
%                              /* variable which is described */
%      int *var_index          /* variable index to be read */
%      string var_name,        /* returned string containing variable name */ 
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    char *sptr; /* ptr to temp staging space for string */
    int slen;
    *ierr=0;     /* default no errror */

    slen = ex_max_name_length;      /* max str size */
    if (var_namelen < slen)
    {
      slen = var_namelen;
    }

    /* Allocate staging space for the variable name */
    if (!(sptr=malloc((slen+1)*sizeof(char))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
    "Error: failed to allocate space for results variable name for file id %d",
                *idexo);
        ex_err("exgvnm",errmsg,EX_MEMFAIL);
      }
      return;
    }

    /* do ExodusII C call to read results variables names */
    if (ex_get_var_name(*idexo,var_type,*var_index,sptr) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      free(sptr);       /* free up allocated space */
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get results variable name from file id %d",
                *idexo);
        ex_err("exgvnm",errmsg,EX_MSG);
      }
      return;
    }

    /* Copy Fortran variable names to staging space */
    /** printf("[exgvnm] var_name(%d): %s\n",*var_index,sptr)); **/
    memset(var_name, 0, var_namelen);
    ex_fcdcpy(var_name,slen,sptr);/* copy string into Fortran buffer */

    free(sptr); /* Free up string staging area */
}

/*
 * put element map
 */
% void
% expem (
%      int *idexo,            /* EXODUS file ID */
%      int *map_id,           /* element map ID */
%      int *elem_map,         /* element map */
%      int *ierr              /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_put_elem_map (*idexo, *map_id, elem_map) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store element map in file id %d",
                *idexo);
        ex_err("expem",errmsg,EX_MSG);
      }
    }
}

/*
 * put partial element map
 */
% void
% exppem (
%      int *idexo,            /* EXODUS file ID */
%      int *map_id,           /* element map ID */
%      int *start,            /* starting entity */
%      int *count,            /* number to write */
%      int *elem_map,         /* element map */
%      int *ierr              /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_put_partial_elem_map (*idexo, *map_id, *start, *count, elem_map) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store element map in file id %d",
                *idexo);
        ex_err("expem",errmsg,EX_MSG);
      }
    }
}

/*
 * put element number map
 */
% void
% expenm (
%      int *idexo,            /* EXODUS file ID */
%      int *elem_map,         /* element order map */
%      int *ierr              /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_put_elem_num_map (*idexo, elem_map) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store element number map in file id %d",
                *idexo);
        ex_err("expenm",errmsg,EX_MSG);
      }
    }
}

/*
 * put map parameters
 */
% void
% expmp (
%      int *idexo,            /* EXODUS file ID */
%      int *num_node_maps,    /* number of node maps */
%      int *num_elem_maps,    /* number of element maps */
%      int *ierr              /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_put_map_param (*idexo, *num_node_maps, *num_elem_maps) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to put map parameters in file id %d",
                *idexo);
        ex_err("expmp",errmsg,EX_MSG);
      }
    }
}

/*
 * put node map
 */
% void
% expnm (
%      int *idexo,            /* EXODUS file ID */
%      int *map_id,           /* node map ID */
%      int *node_map,         /* node map */
%      int *ierr              /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_put_node_map (*idexo, *map_id, node_map) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store node map in file id %d",
                *idexo);
        ex_err("expnm",errmsg,EX_MSG);
      }
    }
}

/*
 * put node number map
 */
% void
% expnnm (
%      int *idexo,            /* EXODUS file ID */
%      int *node_map,         /* node order map */
%      int *ierr              /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    *ierr = 0;
    if (ex_put_node_num_map (*idexo, node_map) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to store node number map in file id %d",
                *idexo);
        ex_err("expnnm",errmsg,EX_MSG);
      }
    }
}

/*
 * write results variable name
 */
% void
% expvnm (
%      int *idexo,             /* EXODUS file ID */
%      string var_type,        /* (single) character indicating the type of */
%                              /* variable which is described */
%      int *var_index          /* variable index to be read */
%      string var_name,        /* string containing variable name */ 
%      int *ierr               /* returned error code */
%      )
% {

  char errmsg[MAX_ERR_LENGTH];


    char *sptr; /* ptr to temp staging space for string */
    int slen;
    *ierr=0;     /* default no errror */

    slen = ex_inquire_int(*idexo, EX_INQ_DB_MAX_ALLOWED_NAME_LENGTH);	/* max str size */
    if (var_namelen < slen)
    {
      slen = var_namelen;
    }

    /* Allocate staging space for the variable name */
    if (!(sptr=(char *)malloc((slen+1)*sizeof(char))))
    {
      *ierr = EX_MEMFAIL;
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
    "Error: failed to allocate space for results variable name for file id %d",
                *idexo);
        ex_err("expvnm",errmsg,EX_MEMFAIL);
      }
      return;
    }

    ex_fstrncpy(sptr,var_name,slen);/* copy string into buffer */


    /* do ExodusII C call to write results variable name */
    if (ex_put_var_name(*idexo,var_type,*var_index,sptr) == EX_FATAL)
    {
      *ierr = EX_FATAL;
      free(sptr);       /* free up allocated space */
      if (exoptval & EX_DEBUG)
      {
        sprintf(errmsg,
               "Error: failed to get write variable name to file id %d",
                *idexo);
        ex_err("expvnm",errmsg,EX_MSG);
      }
      return;
    }

    free(sptr); /* Free up string staging area */
}

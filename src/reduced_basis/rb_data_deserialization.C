////libMesh includes
//#include "libmesh/rb_eim_evaluation.h"
//#include "libmesh/string_to_enum.h"
//#include "libmesh/elem.h"
//#include "libmesh/mesh.h"
//#include "libmesh/rb_data_deserialization.h"
//
//// Cap'n'Proto includes
//#include "capnp/serialize.h"
//
//// C++ includes
//#include <unistd.h>
//#include <iostream>
//#include <fstream>
//#include <fcntl.h>
//
//using namespace libMesh;
//
//using namespace RBDataDeserialization;
//
//// ---- Helper functions (BEGIN) ----
//
//// anonymous namespace for helper functions
//namespace
//{
//
///**
// * Helper function that reads either real or complex numbers, based on
// * the libMesh config options.
// */
//template <typename T>
//inline Number load_scalar_value(const T& value)
//{
//#ifdef LIBMESH_USE_COMPLEX_NUMBERS
//  return Number(value.getReal(), value.getImag());
//#else
//  return value;
//#endif
//}
//
//
//void load_point(RBData::Point3D::Reader point_reader, Point& point)
//{
//  point(0) = point_reader.getX();
//  if(LIBMESH_DIM >= 2)
//  point(1) = point_reader.getY();
//  if(LIBMESH_DIM >= 3)
//  point(2) = point_reader.getZ();
//}
//
//
//void load_elem_into_mesh(
//  RBData::MeshElem::Reader mesh_elem_reader,
//  libMesh::Elem* elem,
//  libMesh::SerialMesh& mesh)
//{
//  auto mesh_elem_point_list = mesh_elem_reader.getPoints();
//  unsigned int n_points = mesh_elem_point_list.size();
//
//  if(n_points != elem->n_nodes())
//  {
//    libmesh_error_msg("Wrong number of nodes for element type");
//  }
//
//  for(unsigned int i=0; i < n_points; ++i)
//  {
//    libMesh::Node* node = new libMesh::Node(mesh_elem_point_list[i].getX(),
//                                            mesh_elem_point_list[i].getY(),
//                                            mesh_elem_point_list[i].getZ());
//
//    mesh.add_node(node);
//
//    elem->set_node(i) = node;
//  }
//  
//  elem->subdomain_id() = mesh_elem_reader.getSubdomainId();
//  
//  mesh.add_elem(elem);
//}
//
//}
//
//// ---- Helper functions (END) ----
//
//// ---- RBEvaluationDeserialization (BEGIN) ----
//
//RBEvaluationDeserialization::RBEvaluationDeserialization(RBEvaluation& rb_eval)
//  :
//  _rb_eval(rb_eval)
//{}
//
//RBEvaluationDeserialization::~RBEvaluationDeserialization()
//{}
//
//void RBEvaluationDeserialization::read_from_file(
//  const std::string& path,
//  bool read_error_bound_data)
//{
//  START_LOG("read_from_file()", "RBEvaluationDeserialization");
//
//  int fd = open(path.c_str(), O_RDONLY);
//  if(!fd)
//  {
//    libmesh_error_msg("Couldn't open the buffer file: " + path);
//  }
//
//  // Turn off the limit to the amount of data we can read in
//  capnp::ReaderOptions reader_options;
//  reader_options.traversalLimitInWords = std::numeric_limits<uint64_t>::max();
//
//  capnp::FdMessageReader message(fd, reader_options);
//
//  RBData::RBEvaluation::Reader rb_eval_reader =
//    message.getRoot<RBData::RBEvaluation>();
//
//  load_rb_evaluation_data(_rb_eval, rb_eval_reader, read_error_bound_data);
//
//  STOP_LOG("read_from_file()", "RBEvaluationDeserialization");
//}
//
//// ---- RBEvaluationDeserialization (END) ----
//
//
//// ---- TransientRBEvaluationDeserialization (BEGIN) ----
//
//TransientRBEvaluationDeserialization::TransientRBEvaluationDeserialization(
//  TransientRBEvaluation& trans_rb_eval)
//  :
//  _trans_rb_eval(trans_rb_eval)
//{}
//
//TransientRBEvaluationDeserialization::~TransientRBEvaluationDeserialization()
//{}
//
//void TransientRBEvaluationDeserialization::read_from_file(
//  const std::string& path,
//  bool read_error_bound_data)
//{
//  START_LOG("read_from_file()", "TransientRBEvaluationDeserialization");
//
//  int fd = open(path.c_str(), O_RDONLY);
//  if(!fd)
//  {
//    libmesh_error_msg("Couldn't open the buffer file: " + path);
//  }
//
//  // Turn off the limit to the amount of data we can read in
//  capnp::ReaderOptions reader_options;
//  reader_options.traversalLimitInWords = std::numeric_limits<uint64_t>::max();
//
//  capnp::FdMessageReader message(fd, reader_options);
//
//  RBData::TransientRBEvaluation::Reader trans_rb_eval_reader =
//    message.getRoot<RBData::TransientRBEvaluation>();
//  RBData::RBEvaluation::Builder rb_eval_reader =
//    trans_rb_eval_reader.getRbEvaluation();
//
//  load_transient_rb_evaluation_data(
//    _trans_rb_eval, rb_eval_reader, trans_rb_eval_reader, read_error_bound_data);
//
//  STOP_LOG("read_from_file()", "TransientRBEvaluationDeserialization");
//}
//
//// ---- TransientRBEvaluationDeserialization (END) ----
//
//
//// ---- RBEIMEvaluationDeserialization (BEGIN) ----
//
//RBEIMEvaluationDeserialization::RBEIMEvaluationDeserialization(
//  RBEIMEvaluation& rb_eim_eval)
//  :
//  _rb_eim_eval(rb_eim_eval)
//{}
//
//RBEIMEvaluationDeserialization::~RBEIMEvaluationDeserialization()
//{}
//
//void RBEIMEvaluationDeserialization::read_from_file(
//  const std::string& path,
//  bool read_error_bound_data)
//{
//  START_LOG("read_from_file()", "RBEIMEvaluationDeserialization");
//
//  int fd = open(path.c_str(), O_RDONLY);
//  if(!fd)
//  {
//    libmesh_error_msg("Couldn't open the buffer file: " + path);
//  }
//
//  // Turn off the limit to the amount of data we can read in
//  capnp::ReaderOptions reader_options;
//  reader_options.traversalLimitInWords = std::numeric_limits<uint64_t>::max();
//
//  capnp::FdMessageReader message(fd, reader_options);
//
//  RBData::RBEIMEvaluation::Reader rb_eim_eval_reader =
//    message.getRoot<RBData::RBEIMEvaluation>();
//  RBData::RBEvaluation::Builder rb_eval_reader =
//    rb_eim_eval_reader.getRbEvaluation();
//
//  load_rb_eim_evaluation_data(
//    _rb_eim_eval, rb_eval_reader, rb_eim_eval_reader, read_error_bound_data);
//
//  STOP_LOG("read_from_file()", "RBEIMEvaluationDeserialization");
//}
//
//// ---- RBEIMEvaluationDeserialization (END) ----
//
//
//// ---- RBSCMEvaluationDeserialization (BEGIN) ----
//
//RBSCMEvaluationDeserialization::RBSCMEvaluationDeserialization(
//  RBSCMEvaluation& rb_scm_eval)
//  :
//  _rb_scm_eval(rb_scm_eval)
//{}
//
//RBSCMEvaluationDeserialization::~RBSCMEvaluationDeserialization()
//{}
//
//void RBSCMEvaluationDeserialization::read_from_file(
//  const std::string& path,
//  bool read_error_bound_data)
//{
//  START_LOG("read_from_file()", "RBSCMEvaluationDeserialization");
//
//  int fd = open(path.c_str(), O_RDONLY);
//  if(!fd)
//  {
//    libmesh_error_msg("Couldn't open the buffer file: " + path);
//  }
//
//  // Turn off the limit to the amount of data we can read in
//  capnp::ReaderOptions reader_options;
//  reader_options.traversalLimitInWords = std::numeric_limits<uint64_t>::max();
//
//  capnp::FdMessageReader message(fd, reader_options);
//
//  RBData::RBEIMEvaluation::Reader rb_scm_eval_reader =
//    message.getRoot<RBData::RBSCMEvaluation>();
//
//  load_rb_scm_evaluation_data(
//    _rb_scm_eval, rb_scm_eval_reader, read_error_bound_data);
//
//  STOP_LOG("read_from_file()", "RBSCMEvaluationDeserialization");
//}
//
//// ---- RBSCMEvaluationDeserialization (END) ----
//
//
//// ---- Helper functions for adding data to capnp Builders (BEGIN) ----
//
//void load_rb_evaluation_data(
//  RBEvaluation& rb_evaluation,
//  RBData::RBEvaluation::Reader& rb_evaluation_reader,
//  bool read_error_bound_data)
//{
//  // Set number of basis functions
//  unsigned int n_bfs = rb_evaluation_reader.getNBfs();
//  rb_evaluation.set_n_basis_functions(n_bfs);
//
//  rb_evaluation.resize_data_structures(n_bfs, read_error_bound_data);
//
//  auto parameter_ranges =
//    rb_evaluation_reader.getParameterRanges();
//  auto discrete_parameters_list =
//    rb_evaluation_reader.getDiscreteParameters();
//  load_parameter_ranges(
//    rb_evaluation, parameter_ranges, discrete_parameters_list);
//
//  const RBThetaExpansion& rb_theta_expansion = rb_evaluation.get_rb_theta_expansion();
//
//  unsigned int n_F_terms = rb_theta_expansion.get_n_F_terms();
//  unsigned int n_A_terms = rb_theta_expansion.get_n_A_terms();
//
//  if(read_error_bound_data)
//  {
//
//    // Fq representor inner-product data
//    {
//      unsigned int Q_f_hat = n_F_terms*(n_F_terms+1)/2;
//
//      auto fq_innerprods_list = rb_evaluation_reader.getFqInnerprods();
//      if(fq_innerprods_list.size() != Q_f_hat)
//      {
//        libmesh_error_msg("Size error while reading Fq representor norm data from buffer.");
//      }
//
//      for(unsigned int i=0; i < Q_f_hat; ++i)
//        rb_evaluation.Fq_representor_innerprods[i] = load_scalar_value(fq_innerprods_list[i]);
//    }
//
//    // Fq_Aq representor inner-product data
//    {
//      auto fq_aq_innerprods_list = rb_evaluation_reader.getFqAqInnerprods();
//      if(fq_aq_innerprods_list.size() != n_F_terms*n_A_terms*n_bfs)
//      {
//        libmesh_error_msg("Size error while reading Fq-Aq representor norm data from buffer.");
//      }
//
//      for(unsigned int q_f=0; q_f<n_F_terms; ++q_f)
//        for(unsigned int q_a=0; q_a<n_A_terms; ++q_a)
//          for(unsigned int i=0; i<n_bfs; ++i)
//          {
//            unsigned int offset = q_f*n_A_terms*n_bfs + q_a*n_bfs + i;
//            rb_evaluation.Fq_Aq_representor_innerprods[q_f][q_a][i] =
//              load_scalar_value(fq_aq_innerprods_list[offset]);
//          }
//    }
//
//    // Aq_Aq representor inner-product data
//    {
//      unsigned int Q_a_hat = n_A_terms*(n_A_terms+1)/2;
//      auto aq_aq_innerprods_list = rb_evaluation_reader.getAqAqInnerprods();
//      if(aq_aq_innerprods_list.size() != Q_a_hat*n_bfs*n_bfs)
//      {
//        libmesh_error_msg("Size error while reading Aq-Aq representor norm data from buffer.");
//      }
//      
//      for(unsigned int i=0; i<Q_a_hat; ++i)
//        for(unsigned int j=0; j<n_bfs; ++j)
//          for(unsigned int l=0; l<n_bfs; ++l)
//          {
//            unsigned int offset = i*n_bfs*n_bfs + j*n_bfs + l;
//            rb_evaluation.Aq_Aq_representor_innerprods[i][j][l] =
//              load_scalar_value(aq_aq_innerprods_list[offset]);
//          }
//    }
//  
//  }
//
//  // Output data
//  {
//    unsigned int n_outputs = rb_theta_expansion.get_n_outputs();
//    
//    auto output_list = rb_evaluation_reader.getOutputs();
//    if(output_list.size() != n_outputs)
//    {
//      libmesh_error_msg("Incorrect number of outputs detected in the buffer");
//    }
//
//    for(unsigned int output_id=0; output_id<n_outputs; ++output_id)
//    {
//      unsigned int n_output_terms = rb_theta_expansion.get_n_output_terms(output_id);
//      unsigned int Q_l_hat = n_output_terms*(n_output_terms+1)/2;
//
//      auto output_dual_innerprods_list = output_list[output_id].getOutputDualInnerprods();
//      if(output_dual_innerprods_list.size() != Q_l_hat)
//      {
//        libmesh_error_msg("Incorrect number of output terms detected in the buffer");
//      }
//      
//      for(unsigned int q=0; q<Q_l_hat; ++q)
//      {
//        rb_evaluation.output_dual_innerprods[output_id][q] =
//          load_scalar_value(output_dual_innerprods_list[q]);
//      }
//        
//      auto output_vectors_outer_list = output_list[output_id].getOutputVectors();
//      if(output_vectors_outer_list.size() != n_output_terms)
//      {
//        libmesh_error_msg("Incorrect number of output vectors detected in the buffer");
//      }
//
//      for(unsigned int q_l=0; q_l<n_output_terms; ++q_l)
//      {
//        auto output_vectors_inner_list = output_vectors_outer_list[q_l];
//
//        if(output_vectors_inner_list.size() != n_bfs)
//        {
//          libmesh_error_msg("Incorrect output vector size detected in the buffer");
//        }
//
//        for(unsigned int j=0; j < n_bfs; ++j)
//        {
//          rb_evaluation.RB_output_vectors[output_id][q_l](j) =
//            load_scalar_value(output_vectors_inner_list[j]);
//        }
//      }
//    }
//  }
//
//  // Fq vectors and Aq matrices
//  {    
//    auto rb_fq_vectors_outer_list = rb_evaluation_reader.getRbFqVectors();
//    if(rb_fq_vectors_outer_list.size() != n_F_terms)
//    {
//      libmesh_error_msg("Incorrect number of Fq vectors detected in the buffer");
//    }
//
//    for(unsigned int q_f=0; q_f<n_F_terms; ++q_f)
//    {
//      auto rb_fq_vectors_inner_list = rb_fq_vectors_outer_list[q_f];
//      if(rb_fq_vectors_inner_list.size() != n_bfs)
//      {
//        libmesh_error_msg("Incorrect Fq vector size detected in the buffer");
//      }
//
//      for(unsigned int i=0; i < n_bfs; ++i)
//      {
//        rb_evaluation.RB_Fq_vector[q_f](i) =
//          load_scalar_value(rb_fq_vectors_inner_list[i]);
//      }
//    }
//
//    auto rb_Aq_matrices_outer_list = rb_evaluation_reader.getRbAqMatrices();
//    if(rb_Aq_matrices_outer_list.size() != n_A_terms)
//    {
//      libmesh_error_msg("Incorrect number of Aq matrices detected in the buffer");
//    }
//
//    for(unsigned int q_a=0; q_a<n_A_terms; ++q_a)
//    {
//      auto rb_Aq_matrices_inner_list = rb_Aq_matrices_outer_list[q_a];
//      if(rb_Aq_matrices_inner_list.size() != n_bfs*n_bfs)
//      {
//        libmesh_error_msg("Incorrect Aq matrix size detected in the buffer");
//      }
//
//      for(unsigned int i=0; i<n_bfs; ++i)
//        for(unsigned int j=0; j<n_bfs; ++j)
//        {
//          unsigned int offset = i*n_bfs+j;
//          rb_evaluation.RB_Aq_vector[q_a](i,j) =
//            load_scalar_value(rb_Aq_matrices_inner_list[offset]);
//        }
//    }
//  }
//
//  // Inner-product matrix
//  if(rb_evaluation.compute_RB_inner_product)
//  {
//    auto rb_inner_product_matrix_list =
//      rb_evaluation_reader.getRbInnerProductMatrix();
//
//    if(rb_inner_product_matrix_list.size() != n_bfs*n_bfs)
//    {
//      libmesh_error_msg("Size error while reading the inner product matrix.");
//    }
//
//    for(unsigned int i=0; i<n_bfs; ++i)
//      for(unsigned int j=0; j<n_bfs; ++j)
//      {
//        unsigned int offset = i*n_bfs + j;
//        rb_evaluation.RB_inner_product_matrix(i,j) =
//          load_scalar_value(rb_inner_product_matrix_list[offset]);
//      }
//  }
//}
//
//
//void RBDataSerialization::load_transient_rb_evaluation(
//  TransientRBEvaluation& trans_rb_eval,
//  RBData::RBEvaluation::Reader& rb_eval_reader,
//  RBData::TransientRBEvaluation::Reader& trans_rb_eval_reader,
//  bool read_error_bound_data)
//{
//  load_rb_evaluation_data(
//    trans_rb_eval, rb_eval_builder, read_error_bound_data);
//
//  trans_rb_eval.set_delta_t( trans_rb_eval_reader.getDeltaT() );
//  trans_rb_eval.set_euler_theta( trans_rb_eval_reader.getEulerTheta() );
//  trans_rb_eval.set_n_time_steps( trans_rb_eval_reader.getNTimeSteps() );
//  trans_rb_eval.set_time_step( trans_rb_eval_reader.getTimeStep() );
//
//  // L2 matrix
//  {
//    auto rb_L2_matrix_list =
//      rb_evaluation_reader.getRbL2Matrix();
//
//    if(rb_L2_matrix_list.size() != n_bfs*n_bfs)
//    {
//      libmesh_error_msg("Size error while reading the L2 matrix.");
//    }
//
//    for(unsigned int i=0; i<n_bfs; ++i)
//      for(unsigned int j=0; j<n_bfs; ++j)
//      {
//        unsigned int offset = i*n_bfs + j;
//        trans_rb_eval.RB_L2_matrix(i,j) =
//          load_scalar_value(rb_inner_product_matrix_list[offset]);
//      }
//  }
//
//  // Mq matrices
//  {
//    unsigned int n_M_terms = rb_theta_expansion.get_n_M_terms();
//
//    auto rb_Mq_matrices_outer_list = trans_rb_eval_builder.getRbMqMatrices();
//
//    if(rb_Mq_matrices_outer_list.size() != n_M_terms)
//    {
//      libmesh_error_msg("Incorrect number of Mq matrices detected in the buffer");
//    }
//
//    for(unsigned int q_m=0; q_m < n_M_terms; ++q_m)
//    {
//      auto rb_Mq_matrices_inner_list = rb_Mq_matrices_outer_list[q_m];
//      if(rb_Mq_matrices_inner_list.size() != n_bfs*n_bfs)
//      {
//        libmesh_error_msg("Incorrect Mq matrix size detected in the buffer");
//      }
//
//      for(unsigned int i=0; i<n_bfs; ++i)
//        for(unsigned int j=0; j<n_bfs; ++j)
//        {
//          unsigned int offset = i*n_bfs+j;
//          trans_rb_eval.RB_M_q_vector[q_m](i,j) =
//            load_scalar_value(rb_Mq_matrices_inner_list[offset]);
//        }
//    }
//  }
//
//  // The initial condition and L2 error at t=0.
//  {
//    auto initial_l2_errors_reader =
//      trans_rb_eval_builder.getInitialL2Errors();
//    if(initial_l2_errors_reader.size() != n_bfs)
//    {
//      libmesh_error_msg("Incorrect number of initial L2 error terms detected in the buffer");
//    }
//
//    auto initial_conditions_outer_list =
//      trans_rb_eval_builder.initInitialCondition();
//    if(initial_conditions_outer_list.size() != n_bfs)
//    {
//      libmesh_error_msg("Incorrect number of outer initial conditions detected in the buffer");
//    }
//
//    for(unsigned int i=0; i<n_bfs; i++)
//    {
//      trans_rb_eval.initial_L2_error_all_N[i] =
//        initial_l2_errors_reader[i];
//
//      auto initial_conditions_inner_list =
//        initial_conditions_outer_list.get(i, i+1);
//
//      auto initial_conditions_inner_list = initial_conditions_outer_list[i];
//      if(initial_conditions_inner_list.size() != (i+1))
//      {
//        libmesh_error_msg(
//          "Incorrect number of inner initial conditions detected in the buffer");
//      }
//
//      for(unsigned int j=0; j<=i; j++)
//      {
//        trans_rb_eval.RB_initial_condition_all_N[i](j) =
//          load_scalar_value(initial_conditions_inner_list[j]);
//      }
//    }
//  }
//
//
//  if(read_error_bound_data)
//  {
//
//    // Fq_Mq data
//    {
//      auto fq_mq_innerprods_list = rb_evaluation_reader.getFqMqInnerprods();
//      if(fq_aq_innerprods_list.size() != n_F_terms*n_M_terms*n_bfs)
//      {
//        libmesh_error_msg(
//          "Size error while reading Fq-Mq representor data from buffer.");
//      }
//
//      for(unsigned int q_f=0; q_f<n_F_terms; ++q_f)
//        for(unsigned int q_m=0; q_m<n_M_terms; ++q_m)
//          for(unsigned int i=0; i<n_bfs; ++i)
//          {
//            unsigned int offset = q_f*n_M_terms*n_bfs + q_m*n_bfs + i;
//            trans_rb_eval.Fq_Aq_representor_innerprods[q_f][q_m][i] =
//              load_scalar_value(fq_mq_innerprods_list[offset]);
//          }
//    }
//
//
//    // Mq_Mq representor inner-product data
//    {
//      unsigned int Q_m_hat = n_M_terms*(n_M_terms+1)/2;
//      auto mq_mq_innerprods_list = rb_evaluation_reader.getMqMqInnerprods();
//      if(mq_mq_innerprods_list.size() != Q_M_hat*n_bfs*n_bfs)
//      {
//        libmesh_error_msg(
//          "Size error while reading Mq-Mq representor data from buffer.");
//      }
//
//      for(unsigned int i=0; i<Q_m_hat; ++i)
//        for(unsigned int j=0; j<n_bfs; ++j)
//          for(unsigned int l=0; l<n_bfs; ++l)
//          {
//            unsigned int offset = i*n_bfs*n_bfs + j*n_bfs + l;
//            trans_rb_eval.Mq_Mq_representor_innerprods[i][j][l] =
//              load_scalar_value(mq_mq_innerprods_list[offset]);
//          }
//    }
//
//    // Aq_Mq representor inner-product data
//    {
//      auto aq_mq_innerprods_list =
//        rb_evaluation_builder.getAqMqInnerprods();
//      if(aq_mq_innerprods_list.size() != n_A_terms*n_M_terms*n_bfs*n_bfs)
//      {
//        libmesh_error_msg(
//          "Size error while reading Aq-Mq representor data from buffer.");
//      }
//
//      for(unsigned int q_a=0; q_a<n_A_terms; q_a++)
//        for(unsigned int q_m=0; q_m<n_M_terms; q_m++)
//          for(unsigned int i=0; i<n_bfs; i++)
//            for(unsigned int j=0; j<n_bfs; j++)
//            {
//              unsigned int offset =
//                q_a*(n_M_terms*n_bfs*n_bfs) + q_m*(n_bfs*n_bfs) + i*n_bfs + j;
//
//              trans_rb_eval.Aq_Mq_representor_innerprods[q_a][q_m][i][j] =
//                load_scalar_value(aq_mq_innerprods_list[offset]);
//            }
//    }
//
//  }
//}
//
//
//void load_rb_eim_evaluation_data(
//  RBEIMEvaluation& rb_eim_evaluation,
//  RBData::RBEvaluation::Reader& rb_evaluation_reader,
//  RBData::RBEIMEvaluation::Reader& rb_eim_evaluation_reader,
//  bool read_error_bound_data)
//{
//  load_rb_evaluation_data(
//    rb_eim_evaluation, rb_evaluation_reader, read_error_bound_data);
//
//  unsigned int n_bfs = rb_eim_evaluation.get_n_basis_functions();  
//
//  // EIM interpolation matrix (with extra row for EIM error bound)
//  {    
//    auto interpolation_matrix_list = rb_eim_evaluation_reader.getInterpolationMatrix();
//
//    if(interpolation_matrix_list.size() != n_bfs*(n_bfs+1)/2)
//    {
//      libmesh_error_msg("Size error while reading the eim inner product matrix.");
//    }
//      
//    for(unsigned int i=0; i<n_bfs; ++i)
//      for(unsigned int j=0; j<=i; ++j)
//      {
//        unsigned int offset = i*(i+1)/2 + j;
//        rb_eim_evaluation.interpolation_matrix(i,j) =
//          load_scalar_value(interpolation_matrix_list[offset]);
//      }
//    
//    auto extra_interpolation_matrix_row_list =
//      rb_eim_evaluation_reader.getExtraInterpolationMatrixRow();
//
//    if(extra_interpolation_matrix_row_list.size() != n_bfs)
//    {
//      libmesh_error_msg("Size error while reading the eim inner product matrix.")
//    }
//
//    for(unsigned int j=0; j<n_bfs; ++j)
//      rb_eim_evaluation.extra_interpolation_matrix_row(j) =
//        load_scalar_value(extra_interpolation_matrix_row_list[j]);
//  }
//
//  // Interpolation points (including the extra point)
//  {
//    auto interpolation_points_list =
//      rb_eim_evaluation_reader.getInterpolationPoints();
//
//    if(interpolation_points_list.size() != n_bfs)
//    {
//      libmesh_error_msg(
//        "Size error while reading the eim interpolation points.");
//    }
//
//    rb_eim_evaluation.interpolation_points.resize(n_bfs);
//    for(unsigned int i=0; i<n_bfs; ++i)
//    {
//      load_point(
//        interpolation_points_list[i],
//        rb_eim_evaluation.interpolation_points[i]);
//    }
//
//    auto extra_interpolation_point_reader =
//      rb_eim_evaluation_reader.getExtraInterpolationPoint();
//    load_point(
//      extra_interpolation_point_reader,
//      rb_eim_evaluation.extra_interpolation_point);
//  }
//
//  // Interpolation points variables (including the "extra one")
//  {
//    auto interpolation_points_var_list =
//      rb_eim_evaluation_reader.getInterpolationPointsVar();
//    rb_eim_evaluation.interpolation_points_var.resize(n_bfs);
//
//    if(interpolation_points_var_list.size() != n_bfs)
//    {
//      libmesh_error_msg(
//        "Size error while reading the eim interpolation variables.");
//    }
//
//    for(unsigned int i=0; i<n_bfs; ++i)
//    {
//      rb_eim_evaluation.interpolation_points_var[i] =
//        interpolation_points_var_list[i];
//    }
//
//    rb_eim_evaluation.extra_interpolation_point_var =
//      rb_eim_evaluation_reader.getExtraInterpolationPointVar();
//  }
//
//  // Interpolation elements (including the "extra one")
//  {
//    libMesh::dof_id_type elem_id = 0;
//    libMesh::SerialMesh& interpolation_points_mesh =
//      rb_eim_evaluation.get_interpolation_points_mesh();
//    interpolation_points_mesh.clear();    
//
//    auto interpolation_points_elem_list =
//      rb_eim_evaluation_reader.getInterpolationPointsElems();
//    unsigned int n_interpolation_elems = interpolation_points_elem_list.size();
//
//    if(n_interpolation_elems != n_bfs)
//    {
//      libmesh_error_msg(
//        "The number of elements should match the number of basis functions");
//    }
//
//    rb_eim_evaluation.interpolation_points_elem.resize(n_interpolation_elems);
//
//    for(unsigned int i=0; i<n_interpolation_elems; ++i)
//    {
//      auto mesh_elem_reader = interpolation_points_elem_list[i];
//      std::string elem_type_name = mesh_elem_reader.getType().cStr();
//      libMesh::ElemType elem_type =
//        libMesh::Utility::string_to_enum<libMesh::ElemType>(elem_type_name);
//
//      libMesh::Elem* elem = libMesh::Elem::build(elem_type).release();
//      elem->set_id(elem_id++);
//      load_elem_into_mesh(mesh_elem_reader, elem, interpolation_points_mesh);
//
//      rb_eim_evaluation.interpolation_points_elem[i] = elem;
//    }
//
//    auto extra_interpolation_point_elem_reader =
//      rb_eim_evaluation_reader.getExtraInterpolationPointElem();
//    std::string elem_type_name =
//      extra_interpolation_point_elem_reader.getType().cStr();
//    libMesh::ElemType elem_type =
//      libMesh::Utility::string_to_enum<libMesh::ElemType>(elem_type_name);
//
//    libMesh::Elem* elem = libMesh::Elem::build(elem_type).release();
//    elem->set_id(elem_id++);
//    load_elem_into_mesh(
//      extra_interpolation_point_elem_reader,
//      elem,
//      interpolation_points_mesh);
//
//    rb_eim_evaluation.extra_interpolation_point_elem = elem;
//  }
//}
//
//void load_rb_scm_evaluation_data(
//  RBSCMEvaluation& rb_scm_evaluation,
//  RBData::RBSCMEvaluation::Reader& rb_scm_evaluation_reader,
//  bool read_error_bound_data)
//{
//  auto parameter_ranges =
//    rb_scm_evaluation_reader.getParameterRanges();
//  auto discrete_parameters_list =
//    rb_evaluation_reader.getDiscreteParameters();
//  load_parameter_ranges(
//    rb_scm_evaluation, parameter_ranges, discrete_parameters_list);
//
//  unsigned int n_A_terms = rb_scm_eval.get_rb_theta_expansion().get_n_A_terms();
//
//  {
//    auto b_min_list = rb_scm_evaluation_reader.getBMin();
//
//    if(b_min_list.size() != n_A_terms)
//    {
//      libmesh_error_msg(
//        "Size error while reading B_min");
//    }
//
//    rb_scm_eval.B_min.clear();
//    for(unsigned int i=0; i<B_min.size(); i++)
//    {
//      rb_scm_eval.B_min.push_back(b_min_list[i]);
//    }
//  }
//
//  {
//    auto b_max_list = rb_scm_evaluation_reader.getBMax();
//
//    if(b_max_list.size() != n_A_terms)
//    {
//      libmesh_error_msg(
//        "Size error while reading B_max");
//    }
//
//    rb_scm_eval.B_max.clear();
//    for(unsigned int i=0; i<B_max.size(); i++)
//    {
//      rb_scm_eval.B_max.push_back(b_max_list[i]);
//    }
//  }
//
//  {
//    auto cJ_stability_vector =
//      rb_scm_eval_reader.getCJStabilityVector();
//
//    rb_scm_eval.C_J_stability_vector.clear();
//    for(unsigned int i=0; i<C_J_stability_vector.size(); i++)
//    {
//      rb_scm_eval.C_J_stability_vector.push_back( cJ_stability_vector[i] );
//    }
//  }
//
//  {
//    auto cJ_parameters_outer =
//      rb_scm_eval_reader.getCJ();
//
//    rb_scm_eval.C_J.clear();
//    for(unsigned int i=0; i<rb_scm_eval.C_J.size(); i++)
//    {
//      auto cJ_parameters_inner =
//        cJ_parameters_outer[i];
//
//      for(unsigned int j=0; j<cJ_parameters_inner.size(); j++)
//      {
//        std::string param_name = cJ_parameters_inner[j].getName();
//        Real param_value = cJ_parameters_inner[j].getValue();
//        rb_scm_eval.C_J[i].set_value(param_name, param_value);
//      }
//    }
//  }
//
//  {
//    auto scm_ub_vectors =
//      rb_scm_eval_reader.scmUbVectors();
//
//    SCM_UB_vectors.resize( C_J_stability_vector.size() );
//    for(unsigned int i=0; i<SCM_UB_vectors.size(); i++)
//    {
//      SCM_UB_vectors[i].resize(n_A_terms);
//      for(unsigned int j=0; j<n_A_terms; j++)
//      {
//        unsigned int offset = i*n_A_terms + j;
//        rb_scm_eval.SCM_UB_vectors[i][j] = scm_ub_vectors[offset];
//      }
//    }
//  }
//}
//
//void load_parameter_ranges(
//  RBParametrized& rb_evaluation,
//  RBData::ParameterRanges::Reader& parameter_ranges,
//  RBData::DiscreteParameterList::Reader& discrete_parameters_list)
//{
//  // Continuous parameters
//  RBParameters parameters_min;
//  RBParameters parameters_max;
//  {
//    unsigned int n_parameter_ranges = parameter_ranges.size();
//    
//    if(rb_evaluation.get_n_params() != n_parameter_ranges)
//    {
//      libmes_error_msg("Mismatch in number of parameters");
//    }
//
//    for(unsigned int i=0; i<n_parameter_ranges; ++i)
//    {
//      std::string parameter_name = parameter_ranges[i].getName();
//      Real min_value = parameter_ranges[i].getMinValue();
//      Real max_value = parameter_ranges[i].getMaxValue();
//
//      parameters_min.set_value(parameter_name, min_value);
//      parameters_max.set_value(parameter_name, max_value);
//    }
//  }
//
//  // Discrete parameters
//  std::map< std::string, std::vector<Real> > discrete_parameter_values;
//  {
//    unsigned int n_discrete_parameters = discrete_parameters_list.size();
//
//    if(rb_evaluation.get_n_discrete_params() != n_discrete_parameters)
//    {
//      libmes_error_msg("Mismatch in number of discrete parameters");
//    }
//
//    for(unsigned int i=0; i<n_discrete_parameters; ++i)
//    {
//      std::string parameter_name = discrete_parameters_list[i].getName();
//
//      auto value_list = discrete_parameter_reader.getValues();
//      unsigned int n_values = value_list.size();
//      std::vector<Real> values(n_values);
//      for(unsigned int j=0; j<n_values; ++j)
//      {
//        values[j] = value_list[j];
//      }
//
//      discrete_parameter_values[parameter_name] = values;
//    }
//  }
//
//  rb_evaluation.initialize_parameters(
//    parameters_min,
//    parameters_max,
//    discrete_parameter_values);
//}
//
//// ---- Helper functions for adding data to capnp Builders (END) ----
